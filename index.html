<!DOCTYPE html>
<html>
<head>
  <title>Lagom Hands-On-Development</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <div class="remote-controller-scaler">
    <input type="checkbox" id="enable-sync" class="subscribe-control" unchecked />
    <label for="enable-sync" class="subscribe-control">講演者と同期</label>
  </div>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページにアクセス
* 「ハンズオンを始める」に従って準備してください

.big[[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)]

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

.footnote[
.height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Akka / Play framework / Scala

.with-twitter-icon[[@negokaz](https://twitter.com/negokaz)] .with-github-icon[[negokaz](https://github.com/negokaz)]

???

* Reactive Platform の検証
    * Reactive System: 高レスポンス、耐障害性があり、スケーラブル なシステム
    * Typesafe がメインで作っている Reactive System を実現するためのフレームワークやライブラリ
    * SI でどのようにすれば活用できるか？

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービス同士を疎結合にすることにより 様々な利点が得られる
* (長いので以降は**MSA**と略します)

???

In short, the microservice architectural style is an approach to developing
a single application as a suite of small services, each running in its own process
and communicating with lightweight mechanisms, often an HTTP resource API.
These services are built around business capabilities and
independently deployable by fully automated deployment machinery.
There is a bare minimum of centralized management of these services,
which may be written in different programming languages and use different data storage technologies.
http://martinfowler.com/articles/microservices.html

---

## MSAの利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

---

## MSAの利点 (2/2)

* レジリエンス(回復性)が得られる
    * 一部のサービスが止まっても全体としては動き続ける
    * すぐに障害から回復できれば ユーザーからは何事も無かったかのように見える
* サービスごとにスケールできる
  * リソースの無駄が少なくなるためコスト効率が良い

---

## MSAのトピックス

* アプリケーション
* インフラストラクチャ
* ドメイン駆動設計
* (人の)組織
* システム運用
* セキュリティ

---

## 今日やること・やらないこと

* .strong[アプリケーション]
* ~~インフラストラクチャ~~
* ~~ドメイン駆動設計~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~

---

## 今日やること

* MSA向けフレームワーク .strong[Lagom] から、MSAにおけるアプリケーションの設計パターンを学ぶ

---

## Lagom とは？

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* 提供されている内部APIは Java
* コアコンセプトは **Reactive** Microservices Architecture
    * 大規模なシステムがターゲット

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]
???
https://www.lightbend.com/company/news/lagom-a-new-microservices-framework
http://www.oreilly.com/programming/free/reactive-microservices-architecture.html
---

## Lagom が目指すもの

.center[
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/bpqBuXOj1fENSp?startSlide=29" width="476" height="388" frameborder="1" marginwidth="0" marginheight="0" scrolling="no"></iframe>
]

.footnote[
[リアクティブ・アーキテクチャ ～大規模サービスにおける必要性と課題〜](http://www.slideshare.net/okapies/reactive-architecture-20160218-58403521)
]

--

.float-bottom-10.center.glass-deep[
.therefore[Lagom にはこの性質を達成するための設計ポリシーがある]
]

---

## Lagom の特徴的な設計ポリシー

* サービス内部で使うAPIは全て非同期API
* 分散型の永続化機構
  * Event Sourcing
  * CQRS
* 外部APIの呼び出しは CircuitBreaker がデフォルトで有効

.footnote[
[Lagom #Lagom design philosophy](http://www.lagomframework.com/documentation/1.0.x/java/LagomDesignPhilosophy.html)

[Lagom #Polyglot systems with Lagom](http://www.lagomframework.com/documentation/1.0.x/java/PolyglotSystems.html)
]
???
今日詳しく見ていくもの

---
class: center, middle

# 今日 Lagom で作るもの

---

## Chirper

Twitter ライクなアプリケーション

* .with-checkbox-on[ユーザー登録]
* .with-checkbox-on[つぶやく]
* .with-checkbox-on[他ユーザーのフォロー]
* .with-checkbox-on[フォロワーと自分のつぶやきを閲覧]

.footnote[
[ネイティブっぽい発音は「ちぇぁぱー」](https://translate.google.co.jp/#en/ja/Chirper)

[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

--

* .with-checkbox-off[.strong[お気に入り (New!)] → WIP]

---
class: center, middle

## Hands-On STEP 1
# 作るものを理解する
はじめての Chirper

---

## 起動

* ターミナルを開いて↓を実行

```bash
$ cd lagom-hands-on-development
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```

⇒ 起動後、Chromeで [http://localhost:9000](http://localhost:9000) にアクセス

---
## サインアップ

.center[
[.with-array-to-bottom[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-form.png)]
]

.footnote[
.bold[※ 後で使うので、ユーザーIDを<br>控えておいてください。]
]
---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.png)]

---

## タイムライン

.height-6[![](resources/img/chirper-timeline.png)]

---

## 現在の進捗

.center[
.height-6[![](resources/img/chirper-favorite-wip.png)]
]

* UIとAPIの一部は実装済み
* お気に入りされてもカウントが常に 0
* お気に入り解除しても開きなおすとお気に入りが復活

---

## 達成したいこと

.center[
.height-6[![](resources/img/chirper-favorite-implemented.png)]
.height-6[![](resources/img/chirper-favorite-deleted.png)]
]

* お気に入りされた数が確認できる
* 間違ってお気に入りしてしまったものを解除できる

---

## サービスの構成 (1/2)

.center[![](resources/img/services1.svg)]

---

## サービスの構成 (2/2)

.center[![](resources/img/services2.svg)]

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write1.svg)]

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write2.svg)]
---

## サービスのAPI - 読取系

.center[![](resources/img/services-read1.svg)]

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read2.svg)]

---
class: center, middle

## Hands-On STEP 2
# サービスのAPIを呼んでみる
Lagom との話し方

---

## Lagom のAPI呼び出し

* Lagomで作成した API は **HTTP** で呼び出せる
* 基本的にデータは **JSON** でやりとりする
    * Serialize・Deserialize が標準サポートされている

---

## HTTPでAPIを呼んでみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

.height-10.center.with-border-frame[
![](resources/img/advanced-rest-client.png)
]

---

### GET - Request

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/users/ユーザーID
    ```
* **GET** を選択
* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-8[![](resources/img/request-get.png)]
]

---

### GET - Response

![](resources/img/response-get.png)

---

### POST - Request

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/chirps/live/ユーザーID
    ```
* **POST** を選択
* Raw Headers:
    ```
    Content-Type: application/json
    ```
* Raw Payload:
    ```
    {"userId": "ユーザー名", "message": "test"}
    ```

* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-10[![](resources/img/request-post.png)]
]

---

### POST - Response

![](resources/img/response-post.png)

---

## Lagom の内部APIで呼んでみる

* WIP の実装をします

.center[![](resources/img/services-read2.svg)]

---

## Lagom の内部APIで呼んでみる

```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          // TODO: 何行目？
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {

              CompletionStage<Integer> favorCount =
                      CompletableFuture.completedFuture(0);

              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));

              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```

---

## Lagom の内部APIで呼んでみる

```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          // TODO: 何行目？
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {

              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();

              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));

              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```

---

## 動きの確認

* お気に入りされた数が確認できる

---

## Lagom の内部APIで呼んでみる

```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          // TODO: 何行目？
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {

              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();

              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));

              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```

.float-bottom-10.glass-deep.small[
* `favoriteService` は 別プロセスで動く FavoriteService の Proxy
* `getFavorCount` はお気に入りされた数を取得するAPI
    * つぶやきのIDを渡す
* `invoke` で結果の `CompletionStage<Integer>` が返ってくる
]

---

## なぜ非同期API？

--
* 応答速度のため
--
.center[![](resources/img/why-asynchronous.svg)]

---

## なぜ非同期API？

* 応答速度のため

* もっと呼び出すAPIが増えたら？
    * レイテンシはより増大
--

* もっとリクエストが増えたら？
    * CPUに余裕があるのにメモリが枯渇
    * いわゆる C10K 問題

---
class: middle, center

## Hands-On STEP 3
# お気に入り"解除"の永続化
事実はずっと忘れない

---

## Lagom における永続化

* 高い可用性とスケーラビリティを実現するため<br>
  .strong[Event Sourcing] と .strong[CQRS] による永続化のしくみを備えている

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
* イベントをデータストアに INSERT していく
* ロック不要
    * 高いスループットを実現できる
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
        * スケールしやすい
        * 耐障害性を高められる

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.1.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.2.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.3.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.4.svg)
]
---

## Event Sourcing

* デメリット
  * データの集計にコストがかかる
  * ⇒ CQRSで解決できる

---

## CQRS

* .bold[C]ommand and .bold[Q]uery .bold[R]esponsibility .bold[S]egregation
    コマンドクエリ責務分離
* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB・データ構造が使える
    * 別々にスケールできるようになる
    * ⇒ Write-Side にイベントソーシングを使い<br>Read-Side に集計しやすい形で永続化する

---

## CQRS

.center[
![](resources/img/es-and-cqrs.svg)
]

---

## CQRS

* デメリット
    * 書き込み・読み込みで完全な一貫性を保てなくなる
      * 十分な時間が経つと整合性がとれる (結果整合性)
      * ⇒ 結果整合性があっても問題ないように
      ビジネスやシステムを設計する

---

## 機能のおさらい

.center[![](resources/img/services-write2.svg)]

---

## APIの実装を確認

.small[[FavoriteService.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java)]
```java
ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```

* `pathCall` の第一引数が API のURLになる
    * URL の `:userId` はパラメータ
    * 例) http://localhost:9000/api/favorites/HOGE/delete

???

this::deleteFavorite は **メソッド参照**

---

## APIの定義を確認
```java
* ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
* `ServiceCall` : APIの呼び出しを抽象化したもの
    * 第一型引数: Request Body の型
  .small[JSONから自動でデシリアライズされる]
    * 第二型引数: Response Body の型
  .small[[NotUsed](http://doc.akka.io/japi/akka/snapshot/akka/NotUsed$.html)はレスポンスボディ無しを表す]

---

## コマンドの送信を実装

.small[[FavoriteServiceImpl.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
*       CompletionStage<Done> adding =
*               favoriteEntityRef(userId).ask(DeleteFavorite.of(userId, request.getFavoriteId()));
*       return adding.thenApply(ack -> NotUsed.getInstance());
    };
}
```

* 「リクエスト.small[(FavoriteId)]を受け取って.small[(NotUsedの)][CompletionStage](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html)を返す」関数を返す
* ややこしいが、あまり気にせず`->`の先で`request`を使った処理を書けば良い

???

CompletionStage: CompletableFuture のスーパークラスで、未来のある時点で値になりうるものを表す

---

## イベントの永続化を実装

.with-checkbox-off[FavoriteEntity を実装する]

* Entity とは、サービスの状態を持つもの
* コマンドを受け取り、自身の状態を更新し、結果を返す
* 状態はDBに永続化する
* イベントは既に用意してあります
    * [FavoriteEvent.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEvent.java)

???

DDDにおけるEntityと一致します。

---

## イベントの永続化を実装

```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
*   b.setCommandHandler(DeleteFavorite.class,
*       (request, ctx) -> {
*           FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
*           return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
*       }
*   );
    //////////////////////////////////////////////
    return b.build();
}
```

---


## イベントの永続化を実装

```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
    b.setCommandHandler(DeleteFavorite.class,
        (request, ctx) -> {
            FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
            return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
        }
    );
    // TODO: STEP3 - FavoriteDeleted(イベント)が起きたときは状態からfavoriteId を削除
*   b.setEventHandler(FavoriteDeleted.class,
*       (evt) -> state().deleteFavoriteId(evt.getFavoriteId())
*   );
    //////////////////////////////////////////////
    return b.build();
}
```

---

## 確認

* お気に入りが解除できるようになっている
* お気に入りされている数が減るのにタイムラグがある

---

## まとめ

* 非同期処理でレイテンシを低くする
* Event Sourcing + CQRS で永続化機能に<br>高いスケーラビリティと耐障害性を持たせる
    * 結果整合性を意識した設計にする

---

## 参考資料

* [マイクロサービスアーキテクチャ (O'Reilly)](https://www.oreilly.co.jp/books/9784873117607/)
* [Reactive Design Patterns (Manning)](https://www.manning.com/books/reactive-design-patterns)
* [Developing Reactive Microservices (O’Reilly)](http://www.oreilly.com/programming/free/developing-reactive-microservices-signup.html)

???
'
---

## 広告

* コンサルティングサービス

---

class: center, middle

## おまけ
# CircuitBreaker の紹介

---

## CircuitBreaker とは？

* Open・Close・Half-Open の状態をとる
* 障害を波及させない
* リクエスト爆発を起こさない

---

.center.height-7[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

### CircitBreaker の分け方

1. FavoriteService に CircitBreaker を定義する

※ CircitBreaker は呼び出し側の制御。
Lagom外からHTTPなどでリクエストを投げる場合は注意

---

</textarea>
  <style>
    .remote-controller {
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.50);
      border: 0.05rem solid rgba(255, 255, 255, 0.80);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      max-width:  0.5rem;
      max-height: 0.5rem;
    }
    @media print {
      .remote-controller {
        visibility: hidden;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".subscribe-control").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          if ($enableSync.prop("checked")) {
            following.sync();
          }
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
        };
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
  </script>
</body>
</html>
