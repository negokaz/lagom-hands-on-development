<!DOCTYPE html>
<html>
<head>
  <title>Title</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <input type="checkbox" id="enable-sync" class="subscribe-control" checked />
  <label for="enable-sync" class="subscribe-control">スライドを同期</label>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページにアクセス
* 「ハンズオンを始める」に従って準備してください

.big[[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)]

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

.footnote[
.height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Akka / Play framework / Scala

.twitter-icon[[@negokaz](https://twitter.com/negokaz)] .github-icon[[negokaz](https://github.com/negokaz)]

???

* Reactive Platform の検証
    * Reactive System: 高レスポンス、耐障害性があり、スケーラブル なシステム
    * Typesafe がメインで作っている Reactive System を実現するためのフレームワークやライブラリ
    * SI でどのようにすれば活用できるか？

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービスどうしを疎結合にすることにより 様々な利点が得られる
* (長いので以降は**MSA**と略します)

???

In short, the microservice architectural style is an approach to developing
a single application as a suite of small services, each running in its own process
and communicating with lightweight mechanisms, often an HTTP resource API.
These services are built around business capabilities and
independently deployable by fully automated deployment machinery.
There is a bare minimum of centralized management of these services,
which may be written in different programming languages and use different data storage technologies.
http://martinfowler.com/articles/microservices.html

---

## 疎結合にすると得られる利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* レジリエンス(回復性)が得られる
  * 一部のサービスが止まっても全体としては動き続ける
  * すぐに障害から復旧できれば ユーザーからは何事も無かったかのように見える

???

「MSAにすると得られる利点」に言い換えられる

---

## 疎結合にすると得られる利点 (2/2)
* サービスごとにスケールできる
  * 無駄なリソースを確保しないのでコスト効率が良い
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

---

## MSAのトピックス

* アプリケーション
* インフラストラクチャ
* (人の)組織
* システム運用
* セキュリティ

---

## 今日やること・やらないこと

* **.accent[アプリケーション]**
* ~~インフラストラクチャ~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~

---

## 今日やること

* MSA向けフレームワーク Lagom から、アプリケーションの設計パターンを学び取る

---

## Lagom とは？

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* **Reactive** Microservices Architecture をコアコンセプトとしている

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]

???
https://www.lightbend.com/company/news/lagom-a-new-microservices-framework
http://www.oreilly.com/programming/free/reactive-microservices-architecture.html

---

## Lagom の主な設計ポリシー

* シンプルなHTTPによるサービス連携
* 分散型の永続化機構
  * CQRS
  * Event Sourcing
* 外部APIの呼び出しは CircuitBreaker がデフォルトで有効
* サービス内部で使うAPIは全て非同期API

???
今日詳しく見ていくもの

---
class: center, middle

# ハンズオン

---

## TODO

.list-no-marker[
* .with-checkbox-off[アプリの概要を知る]
* .with-checkbox-off[アプリのAPIを呼んでみる]
* .with-checkbox-off[Write-side の実装]
* .with-checkbox-off[Read-side の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

# アプリの概要を知る

---

## Chiper

Twitter ライクなアプリケーション

* ユーザー登録
* 他ユーザーのフォロー
* つぶやく

.footnote[
[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

--

* .accent[お気に入り (New!)]

---

## 起動

```bash
$ cd lagom-hands-on-development
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```

---
## サインアップ

.center[
[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-submit.svg)]
]
---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.svg)]

---

## お気に入り

* 今日実装する部分

.height-6[![](resources/img/chirper-favorite.svg)]

---

## 最終的に目指す形

.center[
.height-6[![](resources/img/chirper-favorite-implemented.svg)]
]

* [画面を開き直しても](http://localhost:9000/)お気に入りになっている
* お気に入りされている数が見れる

---

## サービスの構成



---

## Serialization

* Lagom では同期呼び出しと非同期呼び出しがサポートされている
* 同期呼び出し - HTTP
* 非同期呼び出し - WebSocket
* フォーマットはJSONがデフォルトでサポートされている

---

## Hands-on 1 - Lagom のAPIを叩いてみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

### HTTP

### WebSocket

---

## イベントソーシングとCQRS

---

## イベントソーシング

* システムの中で起きた**イベント**を永続化する
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
    * ⇒ スケールしやすくなる
* デメリットは、データを集計するような場合大変
* ⇒ CQRSで回避できる

---

## CQRS

* **C**ommand and **Q**uery **R**esponsibility **S**egregation <br />

    コマンドクエリ責務分離

* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB、データ構造を採用することができるようになる
    * 別々にスケールできるようになる
* 書き込み側にイベントソーシングを使い、読み込み側にクエリしやすい形で保存できる
* デメリットは、読み込み側と書き込み側で完全な一貫性を保てなること

---

## Hands-on 2 - Write-Side の実装

1. FavoriteEntity を実装する
2. FavoriteServiceImpl から FavoriteEntity にコマンドを送る

## 確認

* お気に入りが永続化できている

---

## Hands-on 3 - Read-Side の実装

1. FavoriteEventProcessor を実装する
2. FavoriteServiceImpl からクエリする

## 確認

* お気に入りのカウントが見えるようになる
* ただし、若干のタイムラグがある

---

## CircuitBreaker とは？

* open-close-halfopen
* 障害を波及させない
* リクエスト爆発を起こさない

---

.height-10[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

---

### Hands-on 4 - CircitBreaker の実装

1. FavoriteService に CircitBreaker を定義する

※ CircitBreaker は呼び出し側の制御。
Lagom外からHTTPなどでリクエストを投げる場合は注意

---

## まとめ

* マイクロサービスアーキテクチャで犠牲になること
  * 結果整合性
    * サービスをまたがるトランザクションを作らない
    * サービスをまたがる場合は Saga を検討する

---

## 参考資料

* [マイクロサービスアーキテクチャ]()

???

TODO: なぜ全部非同期なのか？

</textarea>
  <style>
    .remote-controller {
      position: fixed;
      top: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.70);
      border: 0.05rem solid rgb(255, 255, 255);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      width:  0.5rem;
      height: 0.5rem;
    }
    @media print {
      .remote-controller {
        visibility: hidden;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".subscribe-control").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          if ($enableSync.prop("checked")) {
            following.sync();
          }
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
        };
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
  </script>
</body>
</html>
