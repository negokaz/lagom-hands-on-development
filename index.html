<!DOCTYPE html>
<html>
<head>
  <title>Lagom Hands-On-Development</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <input type="checkbox" id="enable-sync" class="subscribe-control" unchecked />
  <label for="enable-sync" class="subscribe-control">スライドを同期</label>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページにアクセス
* 「ハンズオンを始める」に従って準備してください

.big[[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)]

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

.footnote[
.height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Akka / Play framework / Scala

.twitter-icon[[@negokaz](https://twitter.com/negokaz)] .github-icon[[negokaz](https://github.com/negokaz)]

???

* Reactive Platform の検証
    * Reactive System: 高レスポンス、耐障害性があり、スケーラブル なシステム
    * Typesafe がメインで作っている Reactive System を実現するためのフレームワークやライブラリ
    * SI でどのようにすれば活用できるか？

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービスどうしを疎結合にすることにより 様々な利点が得られる
* (長いので以降は**MSA**と略します)

???

In short, the microservice architectural style is an approach to developing
a single application as a suite of small services, each running in its own process
and communicating with lightweight mechanisms, often an HTTP resource API.
These services are built around business capabilities and
independently deployable by fully automated deployment machinery.
There is a bare minimum of centralized management of these services,
which may be written in different programming languages and use different data storage technologies.
http://martinfowler.com/articles/microservices.html

---

## 疎結合にすると得られる利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* レジリエンス(回復性)が得られる
  * 一部のサービスが止まっても全体としては動き続ける
  * すぐに障害から復旧できれば ユーザーからは何事も無かったかのように見える

???

「MSAにすると得られる利点」に言い換えられる

---

## 疎結合にすると得られる利点 (2/2)
* サービスごとにスケールできる
  * 無駄なリソースを確保しないのでコスト効率が良い
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

---

## MSAのトピックス

* アプリケーション
* ドメイン駆動設計
* インフラストラクチャ
* (人の)組織
* システム運用
* セキュリティ

---

## 今日やること・やらないこと

* **.accent[アプリケーション]**
* ~~ドメイン駆動設計~~
* ~~インフラストラクチャ~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~

---

## 今日やること

* MSA向けフレームワーク Lagom から、アプリケーションの設計パターンを学び取る

---

## Lagom とは？

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* **Reactive** Microservices Architecture をコアコンセプトとしている

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]

???
https://www.lightbend.com/company/news/lagom-a-new-microservices-framework
http://www.oreilly.com/programming/free/reactive-microservices-architecture.html

---

## Lagom の主な設計ポリシー

* シンプルなHTTPによるサービス連携
* 分散型の永続化機構
  * CQRS
  * Event Sourcing
* 外部APIの呼び出しは CircuitBreaker がデフォルトで有効
* サービス内部で使うAPIは全て非同期API

???
今日詳しく見ていくもの

---
class: center, middle

# Hands-On

---

## TODO

.list-no-marker[
* .with-checkbox-off[アプリの概要を知る]
* .with-checkbox-off[アプリのAPIを呼んでみる]
* .with-checkbox-off[永続化機能(ES+CQRS)の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

# アプリの概要を知る

---

## Chiper

Twitter ライクなアプリケーション

* ユーザー登録
* 他ユーザーのフォロー
* つぶやく

.footnote[
[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

--

* .accent[お気に入り (New!)]

---

## 起動

```bash
$ cd lagom-hands-on-development
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```

⇒ 起動後、Chromeで [http://localhost:9000](http://localhost:9000) にアクセス

---
## サインアップ

.center[
[.with-array-to-bottom[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-submit.svg)]
]
---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.svg)]

---

## お気に入り

* 今日実装する部分

.height-6[![](resources/img/chirper-favorite.svg)]

---

## 最終的に目指す形

.center[
.height-6[![](resources/img/chirper-favorite-implemented.svg)]
]

* [画面を開き直しても](http://localhost:9000/)お気に入りになっている
* お気に入りされている数が見れる

---

## サービスの構成 - 依存関係

.center[![](resources/img/services-dependency.svg)]

---

## サービスの構成 - 状態を更新

.center[![](resources/img/services-write.svg)]

---

## サービスの構成 - 情報を取得

.center[![](resources/img/services-read.svg)]

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-off[アプリのAPIを呼んでみる]
* .with-checkbox-off[永続化機能(ES+CQRS)の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

## Hands-On STEP 1
# アプリのAPIを呼んでみる

---

## Lagom のAPI呼び出し

* Lagomでは同期呼び出しと非同期呼び出しをサポート
* 同期呼び出し ⇒ HTTP (request-response)
* 非同期呼び出し ⇒ WebSocket
* シリアライズはJSONがサポートされている

---

## アプリのAPIを呼んでみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

### HTTP

### WebSocket

---

## APIの実装を確認

.small[[FavoriteService.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java)]
```java
ServiceCall<FavoriteId, NotUsed> addFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall(`"/api/favorites/:userId/add"`, this::addFavorite)
    )
}
```

* `pathCall` の第一引数が API のURLになる
    * ⇒ http://localhost:9000/api/favorites/HOGE/add

???

this::addFavorite は **メソッド参照**

---

## APIの実装を確認
```java
* ServiceCall<FavoriteId, NotUsed> addFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/add", `this::addFavorite`)
    )
}
```
* `ServiceCall` : APIの呼び出しを抽象化したもの
    * 第一型引数: Request Body の型
  .small[JSONから自動でデシリアライズされる]
    * 第二型引数: Response Body の型
  .small[[NotUsed](http://doc.akka.io/japi/akka/snapshot/akka/NotUsed$.html)はレスポンスボディ無しを表す]

---

## APIの実装を確認

.small[[FavoriteServiceImpl.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> addFavorite(String userId) {
    return request -> {
        return CompletableFuture.completedFuture(NotUsed.getInstance());
    };
}
```

* 「リクエスト.small[(FavoriteId)]を受け取って.small[(NotUsedの)][CompletionStage](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html)を返す」関数を返す
* ややこしいが、あまり気にせず`->`の先で`request`を使った処理を書けば良い

???

CompletionStage: CompletableFuture のスーパークラスで、未来で値になりうるものを表す

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-on[アプリのAPIを呼んでみる]
* .with-checkbox-off[永続化機能(ES+CQRS)の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

# 永続化機能(ES+CQRS)の実装

---

## Event Sourcing と CQRS

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
    * ⇒ スケールしやすくなる
* デメリット
  * データの集計にコストがかかる
  * ⇒ CQRSで解決できる

---

## CQRS (1/2)

* **C**ommand and **Q**uery **R**esponsibility **S**egregation
    コマンドクエリ責務分離
* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB・データ構造が使える
    * 別々にスケールできるようになる
    * ⇒ Write-Side にイベントソーシングを使い<br>Read-Side に集計しやすい形で永続化する

---

## CQRS (2/2)

* デメリット
    * 書き込み・読み込みで完全な一貫性を保てなくなる
    * 十分な時間が経つと整合性がとれる (結果整合性)
    * ⇒ 結果整合性があっても問題ないように
    ビジネスやシステムを設計する

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-on[アプリのAPIを呼んでみる]
* .with-checkbox-off[永続化機能(ES+CQRS)の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-on[アプリのAPIを呼んでみる]
* ~~.with-checkbox-off[永続化機能(ES+CQRS)の実装]~~
* **.with-checkbox-off[CQRS Write-Side の実装]**
* **.with-checkbox-off[CQRS Read-Side の実装]**
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

## Hands-On STEP 2
# CQRS Write-Side の実装

---

## 機能のおさらい

.center[![](resources/img/favorite-functions-write.svg)]

---

## CQRS Write-Side の実装

### TODO
1. .with-checkbox-off[FavoriteEntity を実装する]
2. .with-checkbox-off[FavoriteServiceImpl から FavoriteEntity にコマンドを送る]

---

## CQRS Write-Side の実装

.with-checkbox-off[FavoriteEntity を実装する]

* Entity とは、サービスの状態を持つもの
* コマンドを受け取り、自身の状態を更新し、結果を返す
* 状態はDBに永続化する
* コマンドとレスポンスは既に用意してあります
    * [FavoriteCommand.java](http://localhost:8888/app/lagom-hands-on-development/#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteCommand.java)

???

DDDにおけるEntityと一致します。

---

## CQRS Write-Side の実装


```java
/**
 * 生成直後の Entity の"振る舞い"を定義するメソッド。
 * Entity の状態などによって、違う振る舞いに変更することもできる。
 *
 * @param snapshotState {@link FavoriteState} のスナップショット
 *                      Entity の生成直後は empty。
 *                      Entity の状態を復元する時間を短くするために、
 *                      一定数のイベントが来たタイミングでそのときの状態が永続化される。
 *                      http://www.lagomframework.com/documentation/1.0.x/java/PersistentEntity.html#snapshots
 */
@Override
public Behavior `initialBehavior`(Optional<FavoriteState> `snapshotState`) {
```

---

## CQRS Write-Side の実装

```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
}
```

---

## 確認

* お気に入りが永続化できている

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-on[アプリのAPIを呼んでみる]
* .with-checkbox-on[CQRS Write-Side の実装]
* .with-checkbox-off[CQRS Read-Side の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

## Hands-On STEP 3
# CQRS Read-Side の実装

---

## CQRS Read-Side の実装

1. FavoriteEventProcessor を実装する
2. FavoriteServiceImpl からクエリする

## 確認

* お気に入りのカウントが見えるようになる
* ただし、若干のタイムラグがある

---

## TODO

.list-no-marker[
* .with-checkbox-on[アプリの概要を知る]
* .with-checkbox-on[アプリのAPIを呼んでみる]
* .with-checkbox-on[Write-side の実装]
* .with-checkbox-on[Read-side の実装]
* .with-checkbox-off[CircuitBreaker の実装]
]

---
class: center, middle

## Hands-On STEP 4
# CircuitBreaker の実装

---

## CircuitBreaker とは？

* Open・Close・Half-Open の状態をとる
* 障害を波及させない
* リクエスト爆発を起こさない

---

.center.height-7[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

### Hands-on 4 - CircitBreaker の実装

1. FavoriteService に CircitBreaker を定義する

※ CircitBreaker は呼び出し側の制御。
Lagom外からHTTPなどでリクエストを投げる場合は注意

---

## まとめ

* マイクロサービスアーキテクチャで犠牲になること
  * 結果整合性
    * サービスをまたがるトランザクションを作らない
    * サービスをまたがる場合は Saga を検討する

---

## 参考資料

* [マイクロサービスアーキテクチャ]()

???

TODO: なぜ全部非同期なのか？

---

## 広告

</textarea>
  <style>
    .remote-controller {
      position: fixed;
      bottom: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.70);
      border: 0.05rem solid rgb(255, 255, 255);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      width:  0.5rem;
      height: 0.5rem;
    }
    @media print {
      .remote-controller {
        visibility: hidden;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".subscribe-control").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          if ($enableSync.prop("checked")) {
            following.sync();
          }
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
        };
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
  </script>
</body>
</html>
