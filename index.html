<!DOCTYPE html>
<html>
<head>
  <title>Lagom Hands-On-Development</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <label for="enable-sync" class="subscribe-control">
    <input type="checkbox" id="enable-sync" class="subscribe-control" checked />
    <span>講演者と同期</span>
  </label>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページ(下記)にアクセス
* 「ハンズオンを始める」に従って準備してください

**[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)**

## Feedback

* フィードバックを頂けると嬉しいです！

**[bit.ly/lagom-feedback](http://bit.ly/lagom-feedback)**

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

???

.footnote[
.height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Scala / Akka / Play framework

.with-twitter-icon[[@negokaz](https://twitter.com/negokaz)] .with-github-icon[[negokaz](https://github.com/negokaz)]

???

* Reactive System の推進をミッションとしていて、Lightbend Reactive Platform つまり
Scala や Akka、Play といった技術の検証やコンサルをおこなっています。

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービス同士を疎結合にすることにより .strong[様々な利点]が得られる
* (長いので以降は**MSA**と略します)

???

* さて、今回のテーマはマイクロサービスアーキテクチャということなんですが、
マイクロサービスアーキテクチャってなんなんでしょうか？

マイクロサービスアーキテクチャは ThoughtWorks社の Martin Fowler によって提唱された言葉です。
ざっくり言うと、「小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと」です。
1つのシステムを小さいサービスに分割して、それぞれを疎結合にすることによって、様々な利点を得ることができます。
マイクロサービスアーキテクチャって言うのは疲れるので、以降は MSA と略します。

では、その MSA の利点とはなんでしょうか？

---

## MSAの利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

???

まず、サービスごとに異なる技術が使えるという利点があります。
これにより、サービスの特性に合わせた技術を採用できるようになります。

デプロイの影響範囲を小さくできるという利点もあります。
モノリシックな一枚岩のシステムでは、リリースでシステム全体が影響を受けるので、
リスクがとても大きくなってしまいます。
MSAではその影響範囲を小さくできるので、より低いリスクでリリースができるようになります。
そうなると、修正を入れやすくなるので、新機能などをより早くリリースできるようになります。

---

## MSAの利点 (2/2)

* レジリエンス(回復性)が得られる
    * 一部のサービスが止まっても全体としては動き続ける
    * すぐに障害から回復できれば ユーザーからは何事も無かったかのように見える
* サービスごとにスケールできる
  * リソースの無駄が少なくなるためコスト効率が良い

???



---

## MSAのトピックス

* アプリ層の設計
* インフラ層の設計
* ドメイン駆動設計
* (人の)組織
* システム運用
* セキュリティ
* ...etc

???

MSAのトピックスはいろいろありますが、今日は

---

## 今日やること・やらないこと

* .strong[アプリ層の設計]
* ~~インフラ層の設計~~
* ~~ドメイン駆動設計~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~
* ~~...etc~~

???

各サービスのアプリ層の設計についての話をします

---

## 今日やること

* MSA向けフレームワーク .strong[Lagom] から、MSAにおけるアプリケーションの設計パターンを知る
* Lagom に触れつつ見ていきます

???

今日は

---

## Lagom とは？

.height-3.center[![](resources/img/lagom_logo.svg)]

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* 提供されている内部APIは Java
* コンセプトは **.strong[Reactive] Microservices Architecture**
    * 大規模なシステムがターゲット

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]

???

Lagom とは

---

## Lagom が目指すもの

.center[
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/bpqBuXOj1fENSp?startSlide=29" width="476" height="388" frameborder="1" marginwidth="0" marginheight="0" scrolling="no"></iframe>
]

.footnote[
[リアクティブ・アーキテクチャ ～大規模サービスにおける必要性と課題〜](http://www.slideshare.net/okapies/reactive-architecture-20160218-58403521)
]

--

.float-bottom-10.center.glass-deep[
.therefore[Lagom にはこの性質を達成するための設計ポリシーがある]
]

---

## Lagom の特徴的な設計ポリシー

* サービス内部で使うAPIは全て**非同期API**
* 分散型の永続化機構
  * **Event Sourcing**
  * **CQRS**
* 外部APIの呼び出しは **CircuitBreaker** がデフォルトで有効

.footnote[
[Lagom #Lagom design philosophy](http://www.lagomframework.com/documentation/1.0.x/java/LagomDesignPhilosophy.html)

[Lagom #Polyglot systems with Lagom](http://www.lagomframework.com/documentation/1.0.x/java/PolyglotSystems.html)
]
???
今日詳しく見ていくもの

---
class: center, middle

# 今日 Lagom で作るもの

---

## Chirper

Twitter ライクなアプリケーション

* .with-checkbox-on[ユーザー登録]
* .with-checkbox-on[つぶやく]
* .with-checkbox-on[他ユーザーのフォロー]
* .with-checkbox-on[フォロワーと自分のつぶやきを閲覧]

.footnote[
[ネイティブっぽい発音は「ちぇぁぱー」](https://translate.google.co.jp/#en/ja/Chirper)

[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

--

* .with-checkbox-off[.strong[お気に入り (New!)] → WIP]

---
class: center, middle

## Hands-On STEP 1
# 作るものを理解する
はじめての Chirper

???
**【0:10】**

---

## 起動

* 新しくターミナルを開いて↓を実行

.with-code-annotation[
`Terminal`
```bash
$ cd lagom-hands-on-development
$ git fetch
$ git checkout step1
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```
]

⇒ 起動後、Chromeで [http://localhost:9000](http://localhost:9000) にアクセス

---
## サインアップ

.center[
[.with-array-to-bottom[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-form.png)]
]

.footnote[
.bold[※ 後で使うので、ユーザーIDを<br>控えておいてください。]
]
---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.png)]

---

## タイムライン

.height-6[![](resources/img/chirper-timeline.png)]

--

* お気に入りを on/off したり、 画面を更新したりしてみてください

---

## WIP - 現在の進捗

.center[
.height-6[![](resources/img/chirper-favorite-wip.png)]
]

* UIとAPIの一部は実装済み
* お気に入りされてもカウントが常に 0
* お気に入り解除しても開きなおすとお気に入りが復活

---

## 達成したいこと

.center[
.height-6[![](resources/img/chirper-favorite-implemented.png)]
.height-6[![](resources/img/chirper-favorite-deleted.png)]
]

* お気に入りされた数が確認できる
* 間違ってお気に入りしてしまったものを解除できる

---

## サービスの構成

.center[![](resources/img/services1.svg)]

---

## サービスの構成

.center[![](resources/img/services2.svg)]

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write1.svg)]

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write2.svg)]
---

## サービスのAPI - 読取系

.center[![](resources/img/services-read1.svg)]

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read2.svg)]

---
class: center, middle

## Hands-On STEP 2
# サービスのAPIを呼んでみる
Lagom との話し方

???
**【0:25】**

---

## Lagom のAPI呼び出し

* Lagomで作成した API は **HTTP** で呼び出せる
* 基本的にデータは **JSON** でやりとりする
    * Serialize・Deserialize が標準サポートされている

---

## HTTPでAPIを呼んでみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

.height-10.center.with-border-frame[
![](resources/img/advanced-rest-client.png)
]

---

### GET - ユーザー情報の取得

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/users/ユーザーID
    ```
* **GET** を選択
* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-8[![](resources/img/request-get.png)]
]

---

### GET - Response

![](resources/img/response-get.png)

---

### POST - つぶやきの投稿

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/chirps/live/ユーザーID
    ```
* **POST** を選択
* Raw Headers:
    ```
    Content-Type: application/json
    ```
* Raw Payload:
    ```
    {"userId": "ユーザー名", "message": "test"}
    ```

* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-10[![](resources/img/request-post.png)]
]

---

### POST - Response

![](resources/img/response-post.png)

---

## Lagom の内部APIで呼んでみる

* WIP のところを実装します

.center[![](resources/img/services-read2.svg)]

---

## Lagom の内部APIで呼んでみる

* .with-checkbox-off[ChirpServiceImpl で Favorite の API を呼び出す]

.center[![](resources/img/services-read2.svg)]

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
                      CompletableFuture.completedFuture(0);
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

???

* Activator UI のチュートリアルにソースへのリンクがあります。

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

---

## 動きの確認

* .with-checkbox-on[お気に入りされた数が確認できる]
    * 5秒後ぐらいにリロードしてみてください

.footnote[
※ Lagom はホットリロードをサポートしているので アプリの再起動は不要です
]

???
【5分】

---

## 実装が間に合わなかった場合

下記のコマンドで回答をチェックアウトしてください

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step2
```
]

---

## コードの解説

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
```
]

.small[
* `favoriteService` は FavoriteService の Proxy
    * Proxy が HTTP でリクエストする
* `getFavorCount` はお気に入りされた数を取得するAPI
    * つぶやきのIDを渡す
* `invoke` ですぐに `CompletionStage<Integer>` が返ってくる
    * 非同期処理の戻り値
    * まだ決定していない「未来の値」を表す
]

.footnote[
[Java SE 8 API - `CompletionStage<T>`](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html)
]

---

## なぜ非同期API？

--
* 応答速度のため
--
.center[![](resources/img/why-asynchronous.svg)]

---

## なぜ非同期API？

* 応答速度のため

* もっと呼び出すAPIが増えたら？
    * レイテンシはより増大
    * 呼び出し先のサービスでも同期処理してると…
--

* もっとリクエストが増えたら？
    * CPUに余裕があるのにメモリが枯渇
    * いわゆる C10K 問題

???

* ブロックする呼び出しによってスレッドが専有される

---
class: middle, center

## Hands-On STEP 3
# お気に入り"解除"の永続化
残すのは「今」ではなく「歴史」

???

**【0:55】**

---

## Lagom における永続化

* 高い可用性とスケーラビリティを実現するため<br>
  .strong[Event Sourcing] と .strong[CQRS] による永続化のしくみを備えている

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
* イベントをデータストアに INSERT していく
* ロック不要
    * 高いスループットを実現できる
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
        * スケールしやすい
        * 耐障害性を高められる

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.1.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.2.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.3.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.4.svg)
]
---

## Event Sourcing

* デメリット
  * データの集計にコストがかかる
  * ⇒ CQRSで解決できる

---

## CQRS

* .bold[C]ommand and .bold[Q]uery .bold[R]esponsibility .bold[S]egregation
    コマンドクエリ責務分離
* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB・データ構造が使える
    * 別々にスケールできるようになる
    * ⇒ Command-Side にイベントソーシングを使い<br>Query-Side に集計しやすい形で永続化する

---

## CQRS

.center[
![](resources/img/es-and-cqrs.svg)
]

---

## CQRS

* デメリット
    * 書き込み・読み込みで完全な一貫性を保てなくなる
      * 十分な時間が経つと整合性がとれる (結果整合性)
      * ⇒ 一時的に一貫性が取れてなくても問題ないよう
      ビジネスやシステムを設計する

---

## Event Sourcing で実装してみる

* WIP のところを実装をします

.center[![](resources/img/services-write2.svg)]

---

## Event Sourcing で実装してみる

* .with-checkbox-off[FavoriteService でAPIの定義を確認]
* .with-checkbox-off[FavoriteServiceImpl にコマンドの送信を実装]
* .with-checkbox-off[FavoriteEntity にイベントの永続化を実装]

.height-10.center[![](resources/img/services-write2.svg)]

---

## APIの定義を確認

.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `pathCall` の第一引数が API のURLになる
    * URL の `:userId` はパラメータ
    * 例) http://localhost:9000/api/favorites/HOGE/delete

???

this::deleteFavorite は **メソッド参照**

---

## APIの定義を確認
.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
*ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `ServiceCall` : APIの呼び出しを抽象化したもの
    * 第一型引数: Request Body の型
  .small[JSONから自動でデシリアライズされる]
    * 第二型引数: Response Body の型
  .small[[NotUsed](http://doc.akka.io/japi/akka/snapshot/akka/NotUsed$.html)はレスポンスボディ無しを表す]

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
        return CompletableFuture.completedFuture(NotUsed.getInstance());
    };
}
```
]

* 「`FavoriteId` のリクエストを受けて `CompletionStage<NotUsed>` を返す」関数を返す
* ややこしいが、あまり気にせず`->`の先で`request`を使った処理を書けば良い

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
*       DeleteFavorite command = DeleteFavorite.of(userId, request.getFavoriteId());
*       CompletionStage<Done> deleting = favoriteEntityRef(userId).ask(command);
*       return deleting.thenApply(ack -> NotUsed.getInstance());
    };
}
```
]

* `DeleteFavorite`.small[(コマンド)]を FavoriteEntity に `ask` する
* FavoriteEntity は `userId` ごとに存在している
* `Done` が返って来たら `NotUsed` を返す

???

CompletionStage: CompletableFuture のスーパークラスで、未来のある時点で値になりうるものを表す

---

## Entity？

* サービスの状態を持つもの
* コマンドを受け取り、処理を行う
* コマンドからイベントを作り、イベントを永続化する
* イベントが永続化できたら、自身の状態を更新する
* 状態が失われたら**イベントを再生**して復元

???

DDDにおけるEntityと一致します。

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:27](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:27)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.setCommandHandler(.....,
      (.....) -> { ..... }
    );
    b.setEventHandler(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    `BehaviorBuilder` b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.`setCommandHandler`(.....,
      (.....) -> { ..... }
    );
    b.`setEventHandler`(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

* `BehaviorBuilder` に**コマンド**や**イベント**のハンドラ(関数)を登録する

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
*   b.setCommandHandler(DeleteFavorite.class,
*       (request, ctx) -> {
*           FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
*           return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
*       }
*   );
    //////////////////////////////////////////////
    return b.build();
}
```
]

---


## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
    b.setCommandHandler(DeleteFavorite.class,
        (request, ctx) -> {
            FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
            return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
        }
    );
    // TODO: STEP3 - FavoriteDeleted(イベント)が起きたときは状態からfavoriteId を削除
*   b.setEventHandler(FavoriteDeleted.class,
*       (evt) -> state().deleteFavoriteId(evt.getFavoriteId())
*   );
    //////////////////////////////////////////////
```
]

---

## 動きの確認

* .with-checkbox-on[お気に入りが解除できるようになっている]
* .with-checkbox-on[お気に入りの数が変化するのにタイムラグがある]
.therefore[Query-Side で集計しているため]

???
【10分】

---

## 実装が間に合わなかった場合

回答は下記のコマンドでチェックアウトできます

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step3
```
]

---

## まとめ

* 非同期処理でレイテンシを低くする
* Event Sourcing + CQRS で永続化機能に<br>高いスケーラビリティと耐障害性を持たせる
    * 結果整合性を意識した設計にする

---

## 参考資料

* [マイクロサービスアーキテクチャ (O'Reilly)](https://www.oreilly.co.jp/books/9784873117607/)
* [Reactive Design Patterns (Manning)](https://www.manning.com/books/reactive-design-patterns)
* [Developing Reactive Microservices (O’Reilly)](http://www.oreilly.com/programming/free/developing-reactive-microservices-signup.html)

???
'
---

## TIS㈱ リアクティブ・システム<br>コンサルティングサービス

* Reactive Microservices Architecture
* Akka / Play / Scala
    * POC
    * 設計レビュー
    * コードレビュー
    * システム構築

.footnote[
https://www.tis.jp/service_solution/goreactive/

TIS は Lightbend 社の認定コンサルティングパートナーです
]

---
class: middle, center

# Thank you!

???

90/76

---

class: center, middle

## おまけ
# CircuitBreaker の紹介

---

## CircuitBreaker とは？

.small[
* 外部サービスに障害が起きているとき、すぐエラーの応答を返す仕組み
    * 障害時のリトライによるネットワーク帯域の無駄遣いが減る
    * レイテンシを低く抑えられる
* Close・Open・Half-Open の状態をとる
]

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

## CircuitBreaker のしくみ

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.small[
* **Close**: 外部サービスへリクエストする
* **Open**: すぐにエラーを返す
* **Half-Open**: リクエストを試す
    * Open から一定時間で切り替わる
    * リクエストが成功したら Close に戻る
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

### Lagom での CircitBreaker

* 標準で備えていて、デフォルトで有効
* 外部へのリクエストは CircitBreaker を通じて行う

※ CircitBreaker は呼び出し側の制御
Lagom以外のサービスからLagomのAPIを呼ぶ場合は注意


</textarea>
  <style>
    .remote-controller {
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.50);
      border: 0.05rem solid rgba(255, 255, 255, 0.80);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      max-width:  0.5rem;
      max-height: 0.5rem;
    }
    .subscribe-control {
      cursor: pointer;
    }
    @media print {
      .remote-controller {
        display: none;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script src="resources/js.cookie.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".remote-controller").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          var syncEnabled = $enableSync.prop("checked");
          if (syncEnabled) {
            following.sync();
          }
          Cookies.set("syncEnabled", syncEnabled, { expires: 1 });
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
          Cookies.set("syncEnabled", false, { expires: 1 });
        };
        var syncEnabled = Cookies.get("syncEnabled");
        if (typeof syncEnabled !== "undefined") {
          $enableSync.prop("checked", syncEnabled != "false");
        }
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
    $('.activator-ui-link a').each(function() {
      $(this).attr({target: "activator-ui", href: "http://127.0.0.1:8888/app/lagom-hands-on-development/" + $(this).attr("href")});
    });
  </script>
</body>
</html>
