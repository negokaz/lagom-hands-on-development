<!DOCTYPE html>
<html>
<head>
  <title>Lagom Hands-On-Development</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <label for="enable-sync" class="subscribe-control">
    <input type="checkbox" id="enable-sync" class="subscribe-control" unchecked />
    <span>講演者と同期</span>
  </label>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページ(下記)にアクセス
* 「ハンズオンを始める」に従って準備してください

**[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)**

## Feedback

* フィードバックを頂けると嬉しいです！

**[bit.ly/lagom-feedback](http://bit.ly/lagom-feedback)**

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

.footnote[
TODO: .height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

???

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Scala / Akka / Play framework

.with-twitter-icon[[@negokaz](https://twitter.com/negokaz)] .with-github-icon[[negokaz](https://github.com/negokaz)]

???

私たちは Reactive System の推進をミッションとしていて、Lightbend Reactive Platform つまり
Scala や Akka、Play といった技術の検証やコンサルを おこなっています。

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービス同士を疎結合にすることにより .strong[様々な利点]が得られる
* (長いので以降は**MSA**と略します)

???

さて、今回のテーマはマイクロサービスアーキテクチャということなんですが、
マイクロサービスアーキテクチャってなんなんでしょうか？

マイクロサービスアーキテクチャは ThoughtWorks社の Martin Fowler によって提唱された言葉です。
ざっくり言うと、「小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと」です。
1つのシステムを小さいサービスに分割して、それぞれを疎結合にすることによって、様々な利点を得ることができます。

毎回マイクロサービスアーキテクチャって言うのは疲れるので、以降は MSA と略します。

では、その MSA の利点とはなんでしょうか？

---

## MSAの利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

???

まず、サービスごとに異なる技術が使えるという利点があります。
これにより、サービスの特性に合わせた技術を採用できるようになります。

デプロイの影響範囲を小さくできるという利点もあります。
モノリシックな一枚岩のシステムでは、リリースでシステム全体が影響を受けるので、
リスクがとても大きくなってしまいます。

MSAではその影響範囲を小さくできるので、より低いリスクでリリースができるようになります。
そうなると、修正を入れやすくなるので、新機能などをより早くリリースできるようになります。

---

## MSAの利点 (2/2)

* レジリエンス(回復性)が得られる
    * 一部のサービスが止まっても全体としては動き続ける
    * すぐに障害から回復できれば ユーザーからは何事も無かったかのように見える
* サービスごとにスケールできる
  * リソースの無駄が少なくなるためコスト効率が良い

???

レジリエンスも利点としてあります。
複数あるサービスの一部が止まってしまったとしても、一時的に一部の機能が使えなくなるだけで
ブラウザでページを開いても何も表示されないといったことは起きません。
障害が起きたサービスを復旧できれば、その機能を使っていないユーザーから見ると何事もなかったかのように見えます。

また、サービスごとにスケールできるというのも利点です。
モノリシックなアプリケーションだと、ハイスペックなマシンをどかんと増やすことになり、

TODO:

---

## MSAのトピックス

* アプリ層の設計
* インフラ層の設計
* ドメイン駆動設計
* (人の)組織
* システム運用
* セキュリティ
* ...etc

???

MSAのトピックスはいろいろありますが、今日は

---

## 今日やること・やらないこと

* .strong[アプリ層の設計]
* ~~インフラ層の設計~~
* ~~ドメイン駆動設計~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~
* ~~...etc~~

???

各サービスのアプリ層の設計についての話をします

---

## 今日持ち帰ってもらいたいこと

* MSA向けフレームワーク .strong[Lagom] から、MSAにおけるアプリケーションの設計パターンを知る

???

今日は MSA向けフレームワーク **Lagom** から、MSAにおけるアプリケーションの設計パターンを知って帰ってもらいたいと思います。

--

.therefore[Lagom に触れつつ見ていきます]

???

この設計パターンは、Lagom に触りながら理解していただこうと考えてます。

---

## Lagom とは？

.height-3.center[![](resources/img/lagom_logo.svg)]

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* 提供されている内部APIは Java
* コンセプトは **.strong[Reactive] Microservices Architecture**
    * 大規模なシステムがターゲット

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]

???

Lagom とは

---

## Lagom が目指すもの

.center[
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/bpqBuXOj1fENSp?startSlide=29" width="476" height="388" frameborder="1" marginwidth="0" marginheight="0" scrolling="no"></iframe>
]

.footnote[
[リアクティブ・アーキテクチャ ～大規模サービスにおける必要性と課題〜](http://www.slideshare.net/okapies/reactive-architecture-20160218-58403521)
]

???

Lagom は MSA を採用しつつ、リアクティブ・システムであることを目指しています。
リアクティブ・システムとは、いつでも、たとえ障害があったとしてもユーザーに一貫した速度でレスポンスを返す「即応性」があるシステムのことです。
それを実現するためには、負荷が高くなってもスケールして処理できるようにする「弾力性」
障害が起きたとしても、問題のある部分をすぐに切り離して応答性を維持する「レジリエンス」という性質が必要であると言われています。

Lagom には

--

.float-bottom-10.center.glass-deep[
.therefore[Lagom にはこの性質を達成するための設計ポリシーがある]
]

???

このような性質を達成するためのいくつかの設計ポリシーがあります。

---

## Lagom の特徴的な設計ポリシー

* サービス内部で使うAPIは全て**非同期API**
* 分散型の永続化機構
  * **Event Sourcing**
  * **CQRS**
* 外部APIの呼び出しは **CircuitBreaker** がデフォルトで有効

.footnote[
[Lagom #Lagom design philosophy](http://www.lagomframework.com/documentation/1.0.x/java/LagomDesignPhilosophy.html)

[Lagom #Polyglot systems with Lagom](http://www.lagomframework.com/documentation/1.0.x/java/PolyglotSystems.html)
]
???

Lagomの特徴的な設計ポリシーとして、
内部の処理はノンブロッキング・非同期で実装するということ
分散型の永続化機構である、Event Sourcing と CQRS を使うということ、
外部APIの呼び出しは全て CircuitBreaker を介して行われる
ということがあります。
それぞれの詳細は後で出てくるので、今の時点でことばがわからなくても大丈夫です。

---
class: center, middle

# 今日 Lagom で作るもの

???

さて、これから今日 Lagom で作っていただくものを説明していきたいと思います。

---

## Chirper

Twitter ライクなアプリケーション

* .with-checkbox-on[ユーザー登録]
* .with-checkbox-on[つぶやく]
* .with-checkbox-on[他ユーザーのフォロー]
* .with-checkbox-on[フォロワーと自分のつぶやきを閲覧]

.footnote[
[ネイティブっぽい発音は「ちぇぁぱー」](https://translate.google.co.jp/#en/ja/Chirper)

[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

???

今日作るのは、Chirper と呼ばれる Twitter ライクなアプリケーションです。
元々これは Lagom のサンプルアプリとして公開されているものです。
今回のハンズオンでは皆さんに、

--

* .with-checkbox-off[.strong[お気に入り (New!)] → WIP]

???

お気に入りの機能を追加で実装していただこうと思います。
ただし、全部実装してもらうと時間が足りないので途中まで作っておきました。

---
class: center, middle

## Hands-On STEP 1
# 作るものを理解する
はじめての Chirper

???
**【0:10】**

なにもわからない状態から実装するのはキツいと思うので、まず Chirper について知ってもらおうと思います。

---

## 起動

* 新しくターミナルを開いて↓を実行

.with-code-annotation[
`Terminal`
```bash
$ cd lagom-hands-on-development
$ git fetch
$ git checkout step1
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```
]

⇒ 起動後、Chromeで [http://localhost:9000](http://localhost:9000) にアクセス

???
【1分】

まず、新しいターミナルを開いてここに書いてあるコマンドを実行してください。
アプリが起動できたら、アクセスしてみてください。

何か問題があったらサポートするので教えて下さい。

---
## サインアップ

.center[
[.with-array-to-bottom[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-form.png)]
]

.footnote[
.bold[※ 後で使うので、ユーザーIDを<br>控えておいてください。]
]

???

まず、サインアップしてみましょう。
お好きなIDと、表示名を入力して、サインアップしてください。

---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.png)]

???

サインアップできたら、つぶやきが投稿できるようになっていると思うので
何かつぶやいてみてください。

---

## タイムライン

.height-6[![](resources/img/chirper-timeline.png)]

???

タイムラインにつぶやきが表示されると思います。

--

* お気に入りを on/off したり、 画面を更新したりしてみてください

???

ここで、お気に入りを on/off したり、画面を更新してみてください。
途中までしか作ってないので、少し動きがおかしいところがあると思います。

---

## WIP - 現在の進捗

.center[
.height-6[![](resources/img/chirper-favorite-wip.png)]
]

* UIとAPIの一部は実装済み
* お気に入りされてもカウントが常に 0
* お気に入り解除しても開きなおすとお気に入りが復活

???

ここで、WIP の現在の進捗を確認しておきます。

---

## 達成したいこと

.center[
.height-6[![](resources/img/chirper-favorite-implemented.png)]
.height-6[![](resources/img/chirper-favorite-deleted.png)]
]

* お気に入りされた数が確認できる
* 間違ってお気に入りしてしまったものを解除できる

???

今回のハンズオンで達成したいことは 2 つです。

---

## サービスの構成

.center[![](resources/img/services1.svg)]

???

だいたいの使い方がわかったところで、次は Chirper がどのようなサービスで構成されているか見ていきましょう。
Chirper は 6 つのサービスで構成されています。

---

## サービスの構成

.center[![](resources/img/services2.svg)]

???

それぞれ、どのような責務をになうかというと、
Favorite がお気に入り、Chirp がつぶやき、Activity Stream が画面に表示されるタイムライン、
Friend がユーザーとそのフォロワー、Front-End が UI のレンダリングについて、責務を担うサービスです。

で、次に各サービスがどのように連携しているのか？を説明したいと思います。

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write1.svg)]


???

まず、更新系。
更新はFrontendから直接各サービスにリクエストを投げます。
Favoriteサービスに対してはお気に入りの追加と削除。
Chirpサービスに対してはつぶやきの追加。
Friend に対してはユーザーの作成と友達の追加。
をします。

この中で、まだ作成途中なのが

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write2.svg)]

???

Favoriteサービスでお気に入りの削除をするところがまだ一部未実装です。

次に、読み取り系を見ていきましょう。

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read1.svg)]

???

読取り系は、Activity Stream が Chirpサービス から特定のユーザーと、そのフォロワーのつぶやきを取得したり、
Chirpサービスが特定のユーザーのお気に入りの情報を取ってたりします。

この中で、まだ作成途中なのは

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read2.svg)]

???

ChirpサービスがFavoriteサービスから「つぶやきがお気に入りされている数」を取ってくるところがまだ一部未実装です。

では、まずサービスの呼び出しが具体的にどんなものか知ってもらうために、
サービスのAPI呼び出しを試してもらいます。

---
class: center, middle

## Hands-On STEP 2
# サービスのAPIを呼んでみる
Lagom との話し方

???
**【0:25】**

---

## Lagom のAPI呼び出し

* Lagomで作成した API は **HTTP** で呼び出せる
* 基本的にデータは **JSON** でやりとりする
    * Serialize・Deserialize が標準サポートされている

???

Lagom の API は HTTP で呼び出せます。
基本的にデータは JSON でやりとりします。

---

## HTTPでAPIを呼んでみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

.height-10.center.with-border-frame[
![](resources/img/advanced-rest-client.png)
]

???

ではまず、Advanced REST Client を開いてください。
ここにあるリンクから飛んで「アプリを起動」と書かれたボタンを押して下さい。
こんな感じの画面がひらくと思います。

---

### GET - ユーザー情報の取得

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/users/ユーザーID
    ```
* **GET** を選択
* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-8[![](resources/img/request-get.png)]
]

???

まず、ユーザー情報を取得してみます。
Request URL にここに書いてあるURLを入力してください。
ユーザーIDのところは先ほど登録した自分のIDに置き換えてください。

できたら、「SEND」ボタンをおしてください。
次のページにあるようなレスポンスが返ってきたらOKです。

---

### GET - Response

![](resources/img/response-get.png)

???

---

### POST - つぶやきの投稿

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/chirps/live/ユーザーID
    ```
* **POST** を選択
* Raw Headers:
    ```
    Content-Type: application/json
    ```
* Raw Payload:
    ```
    {"userId": "ユーザーID", "message": "test"}
    ```

* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-10[![](resources/img/request-post.png)]
]

???

次に、つぶやきの投稿をしてみたいと思います。

「SEND」を押すと次のページにあるようなレスポンスが返ってくると思います。

---

### POST - Response

![](resources/img/response-post.png)

???

Lagom ではこのように、普通に REST で API の呼び出しをするようになっています。
これは、サービス間の通信の場合でも同じです。

---

## Lagom の内部APIで呼んでみる

* WIP のところを実装します

.center[![](resources/img/services-read2.svg)]

???

では、次は Lagom のコードで他のサービスの呼び出しを実装してみたいと思います。
ここでは、未実装だった Chirp サービスが Favorite サービスからお気に入りの数を
取ってくるところを実装します。

---

## Lagom の内部APIで呼んでみる

* .with-checkbox-off[ChirpServiceImpl で Favorite の API を呼び出す]

.center[![](resources/img/services-read2.svg)]

???

具体的には ChirpServiceImpl というクラスに実装します。

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
                      CompletableFuture.completedFuture(0);
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

???

ソースの左上にあるリンクを押すとソースに飛べるので、ソースを開いてみてください。

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

???

ここでは、とりあえずハイライトされいている部分のソースを書き換えてください。
後で詳しく解説します。

---

## 動きの確認

* .with-checkbox-on[お気に入りされた数が確認できる]
    * 5秒後ぐらいにリロードしてみてください

.footnote[
※ Lagom はホットリロードをサポートしているので アプリの再起動は不要です
]

???
【5分】

一旦、動きの確認をしてみましょう。

お気に入りしてみて、お気に入りされた数が確認できるようになっていることを確認してみてください。
少しタイムラグがあるので、5秒くらい経ったあとで更新してみてください。

ちなみに、Lagomはホットリロードがサポートされていて、
自動的にソースの変更を反映してくれるので、アプリの再起動は不要です。

---

## コードの解説

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
```
]

.small[
* `favoriteService` は FavoriteService の Proxy
    * Proxy が HTTP でリクエストする
* `getFavorCount` はお気に入りされた数を取得するAPI
    * つぶやきのIDを渡す
* `invoke` ですぐに `CompletionStage<Integer>` が返ってくる
    * 非同期処理の戻り値
    * まだ決定していない「未来の値」を表す
]

.footnote[
[Java SE 8 API - `CompletionStage<T>`](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html)
]

---

## なぜ非同期API？

--
* 応答速度のため
--
.center[![](resources/img/why-asynchronous.svg)]

---

## なぜ非同期API？

* 応答速度のため

* もっと呼び出すAPIが増えたら？
    * レイテンシはより増大
    * 呼び出し先のサービスでも同期処理してると…
--

* もっとリクエストが増えたら？
    * CPUに余裕があるのにメモリが枯渇
    * いわゆる C10K 問題

???

* ブロックする呼び出しによってスレッドが専有される

---

## 実装が間に合わなかった場合

下記のコマンドで回答をチェックアウトしてください

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step2
```
]

---
class: middle, center

## Hands-On STEP 3
# お気に入り"解除"の永続化
残すのは「今」ではなく「歴史」

???

**【0:55】**

---

## Lagom における永続化

* 高い可用性とスケーラビリティを実現するため<br>
  .strong[Event Sourcing] と .strong[CQRS] による永続化のしくみを備えている

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
* イベントをデータストアに INSERT していく
* ロック不要
    * 高いスループットを実現できる
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
        * スケールしやすい
        * 耐障害性を高められる

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.1.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.2.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.3.svg)
]
---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.4.svg)
]
---

## Event Sourcing

* デメリット
  * データの集計にコストがかかる
  * ⇒ CQRSで解決できる

---

## CQRS

* .bold[C]ommand and .bold[Q]uery .bold[R]esponsibility .bold[S]egregation
    コマンドクエリ責務分離
* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB・データ構造が使える
    * 別々にスケールできるようになる
    * ⇒ Command-Side にイベントソーシングを使い<br>Query-Side に集計しやすい形で永続化する

---

## CQRS

.center[
![](resources/img/es-and-cqrs.svg)
]

---

## CQRS

* デメリット
    * 書き込み・読み込みで完全な一貫性を保てなくなる
      * 十分な時間が経つと整合性がとれる (結果整合性)
      * ⇒ 一時的に一貫性が取れてなくても問題ないよう
      ビジネスやシステムを設計する

---

## Event Sourcing で実装してみる

* WIP のところを実装をします

.center[![](resources/img/services-write2.svg)]

---

## Event Sourcing で実装してみる

* .with-checkbox-off[FavoriteService でAPIの定義を確認]
* .with-checkbox-off[FavoriteServiceImpl にコマンドの送信を実装]
* .with-checkbox-off[FavoriteEntity にイベントの永続化を実装]

.height-10.center[![](resources/img/services-write2.svg)]

---

## APIの定義を確認

.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `pathCall` の第一引数が API のURLになる
    * URL の `:userId` はパラメータ
    * 例) http://localhost:9000/api/favorites/HOGE/delete

???

this::deleteFavorite は **メソッド参照**

---

## APIの定義を確認
.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
*ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `ServiceCall` : APIの呼び出しを抽象化したもの
    * 第一型引数: Request Body の型
  .small[JSONから自動でデシリアライズされる]
    * 第二型引数: Response Body の型
  .small[[NotUsed](http://doc.akka.io/japi/akka/snapshot/akka/NotUsed$.html)はレスポンスボディ無しを表す]

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
        return CompletableFuture.completedFuture(NotUsed.getInstance());
    };
}
```
]

* 「`FavoriteId` のリクエストを受けて `CompletionStage<NotUsed>` を返す」関数を返す
* ややこしいが、あまり気にせず`->`の先で`request`を使った処理を書けば良い

???

お気に入りを削除する DeleteFavorite コマンドを FavoriteEntity に送信するコードを実装します。

FavoriteService のインターフェイスで定義された deleteFavorite というメソッドを実装します。
ここでは、ServiceCall の第一型引数にある FavoriteId を受けて、
受けて NotUsed の CompletionStage を返す関数を定義します。
ちょっとAPIがややこしいですが、あまり深く考えずに request の矢印の先にある括弧の中に処理を書けばよいです。

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
*       DeleteFavorite command = DeleteFavorite.of(userId, request.getFavoriteId());
*       CompletionStage<Done> deleting = favoriteEntityRef(userId).ask(command);
*       return deleting.thenApply(ack -> NotUsed.getInstance());
    };
}
```
]

* `DeleteFavorite`.small[(コマンド)]を FavoriteEntity に `ask` する
* FavoriteEntity は `userId` ごとに存在している
* `Done` が返って来たら `NotUsed` を返す

???

書くコードはこんな感じです。

DeleteFavorite というコマンドを作って、userId に紐づく favoriteEntityRef に対してコマンドを ask メソッドで送信します。
EntityRef はここでは、Entity の実体へのプロキシだとイメージしておいてもらえると大丈夫です。
Entity は userId ごとにインスタンスが存在します。
つまり、ユーザー一人に対して Entity が 1つ割あたっているとイメージしてもらえるとよいです。
ask の結果として、コードでは ack と書いちゃってますが、Done が返ってきたら、ServiceCall の第二型引数が NotUsed なので、NotUsed を返すようにします。

---

## Entity？

* サービスの状態を持つもの
* コマンドを受け取り、処理を行う
* コマンドからイベントを作り、イベントを永続化する
* イベントが永続化できたら、自身の状態を更新する
* 状態が失われたら**イベントを再生**して復元

???

DDDにおけるEntityと一致します。

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:27](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:27)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.setCommandHandler(.....,
      (.....) -> { ..... }
    );
    b.setEventHandler(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

???



---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    `BehaviorBuilder` b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.`setCommandHandler`(.....,
      (.....) -> { ..... }
    );
    b.`setEventHandler`(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

* `BehaviorBuilder` に**コマンド**や**イベント**のハンドラ(関数)を登録する

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
*   b.setCommandHandler(DeleteFavorite.class,
*       (request, ctx) -> {
*           FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
*           return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
*       }
*   );
    //////////////////////////////////////////////
    return b.build();
}
```
]

???

伝統的なCRUDのアプリケーションでは DELETE を使ってデータの存在を消していましたが、
イベントソーシングでは DELETE したという事実を残します。

---


## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
    b.setCommandHandler(DeleteFavorite.class,
        (request, ctx) -> {
            FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
            return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
        }
    );
    // TODO: STEP3 - FavoriteDeleted(イベント)が起きたときは状態からfavoriteId を削除
*   b.setEventHandler(FavoriteDeleted.class,
*       (evt) -> state().deleteFavoriteId(evt.getFavoriteId())
*   );
    //////////////////////////////////////////////
```
]

---

## 動きの確認

* .with-checkbox-on[お気に入りが解除できるようになっている]
* .with-checkbox-on[お気に入りの数が変化するのにタイムラグがある]
.therefore[Query-Side で集計しているため]

???
【10分】

---

## 実装が間に合わなかった場合

回答は下記のコマンドでチェックアウトできます

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step3
```
]

---

## まとめ

* 非同期処理でレイテンシを低くする
* Event Sourcing + CQRS で永続化機能に<br>高いスケーラビリティと耐障害性を持たせる
    * 結果整合性を意識した設計にする

---

## 参考資料

* [マイクロサービスアーキテクチャ (O'Reilly)](https://www.oreilly.co.jp/books/9784873117607/)
* [Reactive Design Patterns (Manning)](https://www.manning.com/books/reactive-design-patterns)
* [Developing Reactive Microservices (O’Reilly)](http://www.oreilly.com/programming/free/developing-reactive-microservices-signup.html)

???
'
---

## TIS㈱ リアクティブ・システム<br>コンサルティングサービス

* Reactive Microservices Architecture
* Akka / Play / Scala
    * POC
    * 設計レビュー
    * コードレビュー
    * システム構築

.footnote[
https://www.tis.jp/service_solution/goreactive/

TIS は Lightbend 社の認定コンサルティングパートナーです
]

---
class: middle, center

# Thank you!

???

90/76

---

class: center, middle

## おまけ
# CircuitBreaker の紹介

---

## CircuitBreaker とは？

.small[
* 外部サービスに障害が起きているとき、すぐエラーの応答を返す仕組み
    * 障害時のリトライによるネットワーク帯域の無駄遣いが減る
    * レイテンシを低く抑えられる
* Close・Open・Half-Open の状態をとる
]

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

## Open？ Close？

* CircuitBreaker はもともと電子工学の言葉
* 電流が流れすぎているときに電流を遮断する保護回路

.center.height-6[
![](resources/img/cb-open-close.svg)
]

* **Close**: 回路が**閉じた**状態 = 通信できる
* **Open**: 回路が**開いた**状態 = 通信が遮断されている

---

## CircuitBreaker のしくみ

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.small[
* **Close**: 外部サービスへリクエストする
* **Open**: すぐにエラーを返す
* **Half-Open**: リクエストを試す
    * Open から一定時間で切り替わる
    * リクエストが成功したら Close に戻る
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

### Lagom での CircitBreaker

* 標準で備えていて、デフォルトで有効
* 外部へのリクエストは CircitBreaker を通じて行う

※ CircitBreaker は呼び出し側の制御
Lagom以外のサービスからLagomのAPIを呼ぶ場合は注意


</textarea>
  <style>
    .remote-controller {
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.50);
      border: 0.05rem solid rgba(255, 255, 255, 0.80);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      max-width:  0.5rem;
      max-height: 0.5rem;
    }
    .subscribe-control {
      cursor: pointer;
    }
    @media print {
      .remote-controller {
        display: none;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script src="resources/js.cookie.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".remote-controller").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          var syncEnabled = $enableSync.prop("checked");
          if (syncEnabled) {
            following.sync();
          }
          Cookies.set("syncEnabled", syncEnabled, { expires: 1 });
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
          Cookies.set("syncEnabled", false, { expires: 1 });
        };
        var syncEnabled = Cookies.get("syncEnabled");
        if (typeof syncEnabled !== "undefined") {
          $enableSync.prop("checked", syncEnabled != "false");
        }
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
    $('.activator-ui-link a').each(function() {
      $(this).attr({target: "activator-ui", href: "http://127.0.0.1:8888/app/lagom-hands-on-development/" + $(this).attr("href")});
    });
  </script>
</body>
</html>
