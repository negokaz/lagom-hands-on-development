<!DOCTYPE html>
<html>
<head>
  <title>Lagom Hands-On-Development</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="resources/favicon.ico">
  <link rel="stylesheet" type="text/css" href="resources/light-theme.css" />
</head>
<body>
<div class="remote-controller">
  <label for="enable-sync" class="subscribe-control">
    <input type="checkbox" id="enable-sync" class="subscribe-control" unchecked />
    <span>講演者と同期</span>
  </label>
</div>
<textarea id="source">

## 準備

* ブラウザでスタートページ(下記)にアクセス
* 「ハンズオンを始める」に従って準備してください

**[bit.ly/start-lagom-hands-on](http://bit.ly/start-lagom-hands-on)**

## Feedback

* フィードバックを頂けると嬉しいです！

**[bit.ly/lagom-feedback](http://bit.ly/lagom-feedback)**

---
class: center, middle
background-image: url("resources/img/title-background.jpg")

.glass[
# 変わりゆく要求に備えよ！<br>システムアーキテクチャの新常識<br>「マイクロサービス」<br>を作って体験しよう！
]

.footnote[
.height-4[![](http://2016.techfesta.jp/assets/img/toplogo.png)]
]

???

---

## 私は何者？

* 根来 和輝 .small[Negoro Kazuki]
* TIS株式会社 生産技術R＆D室
* Reactive System に関する技術検証・コンサル
    * Lightbend Reactive Platform
        * Scala / Akka / Play framework

.with-twitter-icon[[@negokaz](https://twitter.com/negokaz)] .with-github-icon[[negokaz](https://github.com/negokaz)]

???

私たちは Reactive System の推進をミッションとしていて、Lightbend Reactive Platform つまり
Scala や Akka、Play といった技術の検証やコンサルを おこなっています。

---

## マイクロサービスアーキテクチャ？

* 2014年3月に ThoughtWorks社 の Martin Fowler によって提唱された
* 小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと
* サービス同士を疎結合にすることにより .strong[様々な利点]が得られる
* (長いので以降は**MSA**と略します)

???

さて、今回のテーマはマイクロサービスアーキテクチャということなんですが、
マイクロサービスアーキテクチャってなんなんでしょうか？

マイクロサービスアーキテクチャは ThoughtWorks社の Martin Fowler によって提唱された言葉です。
ざっくり言うと、「小さいサービスを組み合わせて 一つのアプリケーションを構築するスタイルのこと」です。
1つのシステムを小さいサービスに分割して、それぞれを疎結合にすることによって、様々な利点を得ることができます。

毎回マイクロサービスアーキテクチャって言うのは疲れるので、以降は MSA と略します。

では、その MSA の利点とはなんでしょうか？

---

## MSAの利点 (1/2)

* サービスごとに異なる技術が使える
  * サービスの特性に合った技術を採用できる
* デプロイの影響範囲を小さくできる
  * 新機能や修正を迅速にリリースできる

???

まず、サービスごとに異なる技術が使えるという利点があります。
これにより、サービスの特性に合わせた技術を採用できるようになります。

デプロイの影響範囲を小さくできるという利点もあります。
モノリシックな一枚岩のシステムでは、リリースでシステム全体が影響を受けるので、
リスクがとても大きくなってしまいます。

MSAではその影響範囲を小さくできるので、より低いリスクでリリースができるようになります。
そうなると、修正を入れやすくなるので、新機能などをより早くリリースできるようになります。

---

## MSAの利点 (2/2)

* レジリエンス(回復性)が得られる
    * 一部のサービスが止まっても全体としては動き続ける
    * すぐに障害から回復できれば ユーザーからは何事も無かったかのように見える
* サービスごとにスケールできる
  * リソースの無駄が少なくなるためコスト効率が良い

???

レジリエンスも利点としてあります。
複数あるサービスの一部が止まってしまったとしても、一時的に一部の機能が使えなくなるだけで
ブラウザでページを開いても何も表示されないといったことは起きません。
障害が起きたサービスを復旧できれば、その機能を使っていないユーザーから見ると何事もなかったかのように見えます。

また、サービスごとにスケールできるというのも利点です。
モノリシックなアプリケーションだと、ハイスペックなマシンをどかんと増やすことになり、

TODO:

---

## MSAのトピックス

* アプリ層の設計
* インフラ層の設計
* ドメイン駆動設計
* (人の)組織
* システム運用
* セキュリティ
* ...etc

???

MSAのトピックスはいろいろありますが、今日は

---

## 今日やること・やらないこと

* .strong[アプリ層の設計]
* ~~インフラ層の設計~~
* ~~ドメイン駆動設計~~
* ~~(人の)組織~~
* ~~システム運用~~
* ~~セキュリティ~~
* ~~...etc~~

???

各サービスのアプリ層の設計についての話をします

---

## 今日持ち帰ってもらいたいこと

* MSA向けフレームワーク .strong[Lagom] から、MSAにおけるアプリケーションの設計パターンを知る

???

今日は MSA向けフレームワーク **Lagom** から、MSAにおけるアプリケーションの設計パターンを知って帰ってもらいたいと思います。

--

.therefore[Lagom に触れつつ見ていきます]

???

この設計パターンは、Lagom に触りながら理解していただこうと考えてます。

---

## Lagom とは？

.height-3.center[![](resources/img/lagom_logo.svg)]

* Lightbend社が3月にリリースしたMSA向けフレームワーク
* 提供されている内部APIは Java
* コンセプトは **.strong[Reactive] Microservices Architecture**
    * 大規模なシステムがターゲット

.footnote[
[https://www.lightbend.com/lagom](https://www.lightbend.com/lagom)

[Reactive Microservices Architecture (O’Reilly)](http://www.oreilly.com/programming/free/reactive-microservices-architecture.html)
]

???

Lagom とは

---

## Lagom が目指すもの

.center[
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/bpqBuXOj1fENSp?startSlide=29" width="476" height="388" frameborder="1" marginwidth="0" marginheight="0" scrolling="no"></iframe>
]

.footnote[
[リアクティブ・アーキテクチャ ～大規模サービスにおける必要性と課題〜](http://www.slideshare.net/okapies/reactive-architecture-20160218-58403521)
]

???

Lagom は MSA を採用しつつ、リアクティブ・システムであることを目指しています。
リアクティブ・システムとは、いつでも、たとえ障害があったとしてもユーザーに一貫した速度でレスポンスを返す「即応性」があるシステムのことです。
それを実現するためには、負荷が高くなってもスケールして処理できるようにする「弾力性」
障害が起きたとしても、問題のある部分をすぐに切り離して応答性を維持する「レジリエンス」という性質が必要であると言われています。

Lagom には

--

.float-bottom-10.center.glass-deep[
.therefore[Lagom にはこの性質を達成するための設計ポリシーがある]
]

???

このような性質を達成するためのいくつかの設計ポリシーがあります。

---

## Lagom の特徴的な設計ポリシー

* サービス内部で使うAPIは全て**非同期API**
* 分散型の永続化機構
  * **Event Sourcing**
  * **CQRS**
* 外部APIの呼び出しは **CircuitBreaker** がデフォルトで有効

.footnote[
[Lagom #Lagom design philosophy](http://www.lagomframework.com/documentation/1.0.x/java/LagomDesignPhilosophy.html)

[Lagom #Polyglot systems with Lagom](http://www.lagomframework.com/documentation/1.0.x/java/PolyglotSystems.html)
]
???

Lagomの特徴的な設計ポリシーとして、
内部の処理はノンブロッキング・非同期で実装するということ
分散型の永続化機構である、Event Sourcing と CQRS を使うということ、
外部APIの呼び出しは全て CircuitBreaker を介して行われる
ということがあります。
それぞれの詳細は後で出てくるので、今の時点でことばがわからなくても大丈夫です。

---
class: center, middle

# 今日 Lagom で作るもの

???

さて、これから今日 Lagom で作っていただくものを説明していきたいと思います。

---

## Chirper

Twitter ライクなアプリケーション

* .with-checkbox-on[ユーザー登録]
* .with-checkbox-on[つぶやく]
* .with-checkbox-on[他ユーザーのフォロー]
* .with-checkbox-on[フォロワーと自分のつぶやきを閲覧]

.footnote[
[https://github.com/lagom/activator-lagom-java-chirper](https://github.com/lagom/activator-lagom-java-chirper)
]

???

今日作るのは、Chirper と呼ばれる Twitter ライクなアプリケーションです。
元々これは Lagom のサンプルアプリとして公開されているものです。
今回のハンズオンでは皆さんに、

--

* .with-checkbox-off[.strong[お気に入り (New!)] → WIP]

???

お気に入りの機能を追加で実装していただこうと思います。
ただし、全部実装してもらうと時間が足りないので途中まで作っておきました。

---
class: center, middle

## Hands-On STEP 1
# 作るものを理解する
はじめての Chirper

???
**【0:10】**

なにもわからない状態から実装するのはキツいと思うので、まず Chirper について知ってもらおうと思います。

---

## 起動

* 新しくターミナルを開いて↓を実行

.with-code-annotation[
`Terminal`
```bash
$ cd lagom-hands-on-development
$ git fetch
$ git checkout step1
$ bin/activator runAll
....
* [info] (Services started, use Ctrl+D to stop and go back to the console...) # 起動完了
```
]

⇒ 起動後、Chromeで [http://localhost:9000](http://localhost:9000) にアクセス

???
【1分】

まず、新しいターミナルを開いてここに書いてあるコマンドを実行してください。
アプリが起動できたら、アクセスしてみてください。

何か問題があったらサポートするので教えて下さい。

---
## サインアップ

.center[
[.with-array-to-bottom[.height-5.with-cursor[![](resources/img/chirper-signup.svg)]]](http://localhost:9000/signup)

.height-8.with-bottom-cursor[![](resources/img/chirper-signup-form.png)]
]

.footnote[
.bold[※ 後で使うので、ユーザーIDを<br>控えておいてください。]
]

???

まず、サインアップしてみましょう。
お好きなIDと、表示名を入力して、サインアップしてください。

---

## つぶやく

.height-6.with-bottom-cursor[![](resources/img/chirper-chirp.png)]

???

サインアップできたら、つぶやきが投稿できるようになっていると思うので
何かつぶやいてみてください。

---

## タイムライン

.height-6[![](resources/img/chirper-timeline.png)]

???

タイムラインにつぶやきが表示されると思います。

--

* お気に入りを on/off したり、 画面を更新したりしてみてください

???

ここで、お気に入りを on/off したり、画面を更新してみてください。
途中までしか作ってないので、少し動きがおかしいところがあると思います。

---

## WIP - 現在の進捗

.center[
.height-6[![](resources/img/chirper-favorite-wip.png)]
]

* UIとAPIの一部は実装済み
* お気に入りされてもカウントが常に 0
* お気に入り解除しても開きなおすとお気に入りが復活

???

ここで、WIP の現在の進捗を確認しておきます。

---

## 達成したいこと

.center[
.height-6[![](resources/img/chirper-favorite-implemented.png)]
.height-6[![](resources/img/chirper-favorite-deleted.png)]
]

* お気に入りされた数が確認できる
* 間違ってお気に入りしてしまったものを解除できる

???

今回のハンズオンで達成したいことは 2 つです。

---

## サービスの構成

.center[![](resources/img/services1.svg)]

???

だいたいの使い方がわかったところで、次は Chirper がどのようなサービスで構成されているか見ていきましょう。
Chirper は 6 つのサービスで構成されています。

---

## サービスの構成

.center[![](resources/img/services2.svg)]

???

それぞれ、どのような責務をになうかというと、
Favorite がお気に入り、Chirp がつぶやき、Activity Stream が画面に表示されるタイムライン、
Friend がユーザーとそのフォロワー、Front-End が UI のレンダリングについて、責務を担うサービスです。

で、次に各サービスがどのように連携しているのか？を説明したいと思います。

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write1.svg)]


???

まず、更新系。
更新はFrontendから直接各サービスにリクエストを投げます。
Favoriteサービスに対してはお気に入りの追加と削除。
Chirpサービスに対してはつぶやきの追加。
Friend に対してはユーザーの作成と友達の追加。
をします。

この中で、まだ作成途中なのが

---

## サービスのAPI - 更新系

.center[![](resources/img/services-write2.svg)]

???

Favoriteサービスでお気に入りの削除をするところがまだ一部未実装です。

次に、読み取り系を見ていきましょう。

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read1.svg)]

???

読取り系は、Activity Stream が Chirpサービス から特定のユーザーと、そのフォロワーのつぶやきを取得したり、
Chirpサービスが特定のユーザーのお気に入りの情報を取ってたりします。

この中で、まだ作成途中なのは

---

## サービスのAPI - 読取系

.center[![](resources/img/services-read2.svg)]

???

ChirpサービスがFavoriteサービスから「つぶやきがお気に入りされている数」を取ってくるところがまだ一部未実装です。

では、まずサービスの呼び出しが具体的にどんなものか知ってもらうために、
サービスのAPI呼び出しを試してもらいます。

---
class: center, middle

## Hands-On STEP 2
# サービスのAPIを呼んでみる
Lagom との話し方

???
**【0:25】**

---

## Lagom のAPI呼び出し

* Lagomで作成した API は **HTTP** で呼び出せる
* 基本的にデータは **JSON** でやりとりする
    * Serialize・Deserialize が標準サポートされている

???

Lagom の API は HTTP で呼び出せます。
基本的にデータは JSON でやりとりします。

---

## HTTPでAPIを呼んでみる

[Advanced REST Client を起動](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo/)

.height-2.with-cursor[
![](resources/img/chrome-app-launch.png)
]

.height-10.center.with-border-frame[
![](resources/img/advanced-rest-client.png)
]

???

ではまず、Advanced REST Client を開いてください。
ここにあるリンクから飛んで「アプリを起動」と書かれたボタンを押して下さい。
こんな感じの画面がひらくと思います。

---

### GET - ユーザー情報の取得

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/users/ユーザーID
    ```
* **GET** を選択
* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-8[![](resources/img/request-get.png)]
]

???

まず、ユーザー情報を取得してみます。
Request URL にここに書いてあるURLを入力してください。
ユーザーIDのところは先ほど登録した自分のIDに置き換えてください。

できたら、「SEND」ボタンをおしてください。
次のページにあるようなレスポンスが返ってきたらOKです。

---

### GET - Response

![](resources/img/response-get.png)

???

---

### POST - つぶやきの投稿

.left-column[
* Request URL:
    ```
    http://localhost:9000/api/chirps/live/ユーザーID
    ```
* **POST** を選択
* Raw Headers:
    ```
    Content-Type: application/json
    ```
* Raw Payload:
    ```
    {"userId": "ユーザーID", "message": "test"}
    ```

* .with-cursor[![](resources/img/advanced-rest-client-send.png)]
]

.right-column[
.height-10[![](resources/img/request-post.png)]
]

???

次に、つぶやきの投稿をしてみたいと思います。

「SEND」を押すと次のページにあるようなレスポンスが返ってくると思います。

---

### POST - Response

![](resources/img/response-post.png)

???

Lagom ではこのように、普通に REST で API の呼び出しをするようになっています。
これは、サービス間の通信の場合でも同じです。

---

## Lagom の内部APIで呼んでみる

* WIP のところを実装します

.center[![](resources/img/services-read2.svg)]

???

では、次は Lagom のコードで他のサービスの呼び出しを実装してみたいと思います。
ここでは、未実装だった Chirp サービスが Favorite サービスからお気に入りの数を
取ってくるところを実装します。

---

## Lagom の内部APIで呼んでみる

* .with-checkbox-off[ChirpServiceImpl で Favorite の API を呼び出す]

.center[![](resources/img/services-read2.svg)]

???

具体的には ChirpServiceImpl というクラスに実装します。

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
                      CompletableFuture.completedFuture(0);
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

???

ソースの左上にあるリンクを押すとソースに飛べるので、ソースを開いてみてください。

---

## Lagom の内部APIで呼んでみる

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
  public ServiceCall<LiveChirpsRequest, Source<Chirp, ?>> getLiveChirps(String userId) {
          /////////////////////////////////////////
          return recentChirpSource.thenApply(source -> {
            return source.mapAsync(2, chirp -> {
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
              // つぶやきにお気に入りの情報を追加
              CompletionStage<Chirp> chirpAppliedFavorite =
                favorites.thenCompose(favs ->
                favorCount.thenApply(count ->
                  favs.contains(chirp.getUuid())
                          ? chirp.withIsFavorite(true).withFavorCount(count)
                          : chirp.withFavorCount(count)
                ));
              return chirpAppliedFavorite;
            });
          });
          /////////////////////////////////////////
}
```
]

???

見て頂いてる getLiveChirps というメソッドは特定のユーザーのつぶやきのストリームを取得するAPIです。

ここでは、とりあえずハイライトされいている部分のソースを書き換えてください。
後で詳しく解説します。

---

## 動きの確認

* .with-checkbox-on[お気に入りされた数が確認できる]
    * 5秒後ぐらいにリロードしてみてください

.footnote[
※ Lagom はホットリロードをサポートしているので アプリの再起動は不要です
]

???
【5分】

一旦、動きの確認をしてみましょう。

お気に入りしてみて、お気に入りされた数が確認できるようになっていることを確認してみてください。
少しタイムラグがあるので、5秒くらい経ったあとで更新してみてください。

ちなみに、Lagomはホットリロードがサポートされていて、
自動的にソースの変更を反映してくれるので、アプリの再起動は不要です。

---

## コードの解説

.with-code-annotation[
.activator-ui-link[[ChirpServiceImpl.java:114](#code/chirp-impl/src/main/java/sample/chirper/chirp/impl/ChirpServiceImpl.java:114)]
```java
              // TODO: STEP2 - DeleteFavorite(コマンド)をFavoriteEntityに送る
              CompletionStage<Integer> favorCount =
*                     favoriteService.getFavorCount(chirp.getUuid()).invoke();
```
]

.small[
* `favoriteService` は FavoriteService の Proxy
    * Proxy が HTTP でリクエストする
* `getFavorCount` はお気に入りされた数を取得するAPI
    * つぶやきのIDを渡す
* `invoke` ですぐに `CompletionStage<Integer>` が返ってくる
    * 非同期処理の戻り値
    * まだ決定していない「未来の値」を表す
]

.footnote[
[Java SE 8 API - CompletionStage&amp;lt;T&amp;gt;](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html)
]

???

favoriteService は FavoriteServiceの実体への Proxy です。 (java.lang.reflect.Proxy)
getFavorCount がお気に入りされた数を取得するAPIです。
getFavorCount で ServiceCall というAPIの呼び出しを抽象化したオブジェクトが返ってくるので、
そのオブジェクトの invoke を呼び出します。

invoke を呼び出すと、 CompletionStage という非同期処理の戻り値が返ってきます。
簡単に言うと、まだ決定していない「未来の値」を表します。

---

## なぜ非同期API？

???

では、なぜ Lagom ではこのように非同期のAPIが採用されているのでしょうか？

--
* 応答速度のため

???

一つは応答速度のためです。

--
.center[![](resources/img/why-asynchronous.svg)]

???

先ほど実装して頂いたコードでは、大きく3つのことをしています。
* １つは、つぶやきの一覧を取得すること
* ２つ目に、取ってきたつぶやきがお気に入りされた数を取得すること
* ３つ目に、ユーザーがお気に入りしたつぶやきのIDを取ってくること です。

同期処理では、まずつぶやきの一覧をとってきて、その一覧を元にお気に入りされた数を取りに行って、
最後にお気に入りしたつぶやきのIDを取ってくる、という感じになると思います。

非同期だと、まずつぶやきの一覧を取りに行くのと③のユーザーがお気に入りしたつぶやきのIDを取ってくるのは同時にリクエストすることができます。
お気に入りされた数は、つぶやきの一覧に紐付けて取りに行かないといけないので、少し出遅れますが、
何件かつぶやきが取れてきた時点から、数の問い合わせが開始できます。

トータルで見ると、かなりの時間短縮ができているのがお分かりいただけるとおもいます。

同期処理として実装した場合のリスクとしては、次のようなことが考えられます。

---

## 同期処理として実装した場合のリスク

* もっと呼び出すAPIが増えたら？
    * レイテンシはより増大
    * 呼び出し先のサービスでも同期処理してると…

???

同期処理として実装した場合、APIの呼び出しが更に4つ5つと増えていくと、
さらにレイテンシが増大してしまうという問題があります。

さらに呼び出した先でも同期処理をしていると、どんどんレイテンシが蓄積されていくことになります。
MSAにすると、ネットワークのオーバーヘッドが大きくなるので、この問題がさらに大きくなる可能性があります。

--

* もっとリクエストが増えたら？
    * スレッドの消費が増えてメモリが枯渇
    * いわゆる C10K 問題

???

さらに、リクエストがとても増えた場合に一つ一つのリクエストがスレッドを消費するのでスレッドが大量に必要になります。
そうなると、メモリが枯渇してしまいます。いわゆるクライアント10K問題が起きる可能性があります。

以上のことから、大規模なMSAにおいては非同期APIで実装することが大事になります。

---

## 実装が間に合わなかった場合

下記のコマンドで回答をチェックアウトしてください

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step2
```
]

???

もし、先ほどのハンズオンが実装できなかった方がいれば、
次に進むのでこのコマンドで回答をチェックアウトしておいてください。

続いては、

---
class: middle, center

## Hands-On STEP 3
# お気に入り"解除"の永続化
残すのは「今」ではなく「歴史」

???

**【0:55】**

お気に入り解除の永続化を実装していきます。
ここから少し難しくなるので、ちょっと気合入れて下さい。

---

## Lagom における永続化

* 高い可用性とスケーラビリティを実現するため<br>
  .strong[Event Sourcing] と .strong[CQRS] による永続化のしくみを備えている

???

Lagom での永続化は少し特殊です。
高い可用性とスケーラビリティを実現するために Event Sourcing と CQRS という方式が標準になっています。

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
* イベントをデータストアに INSERT していく
* ロック不要
    * 高いスループットを実現できる
* イベントは不変(immutable)
    * キャッシュ、コピー、共有が容易にできる
        * スケールしやすい
        * 耐障害性を高められる

???

Event Sourcing はシステムの中で起きたイベントを永続化するという方式です。
例えば「ユーザーがお気に入りした」「ユーザーがお気に入りを解除」したといったイベントを永続化していきます。

イベントはデータストアに次々に INSERT されていきます。

データをINSERTするだけなので、ロックが不要になり高いスループットを実現することができるようになります。

また、イベントはイミュータブルなので、キャッシュやコピー、共有といったことが簡単にできて、
スケールがしやすくなり、またレプリカも簡単に作れるので耐障害性も高めやすいです。

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.1.svg)
]

???

少しイメージをつけてもらうために、図にしてみました。
Event Source がイベントを蓄積しておくところです。
現在の状態は誰が持つの？ということについては、Lagom では Entity というものが現在の状態を持ちます。

ID:1 のつぶやきをお気に入り追加というイベントが起きれば、Entityではお気に入りは ID:1 だけですという状態になります。

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.2.svg)
]

???

ID:2 のつぶやきをお気に入り追加というイベントが起きれば、Entity ではお気に入りは ID:1 と 2 ですという状態になります。

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.3.svg)
]

???

ID:1 のつぶやきのお気に入りを削除というイベントが起きれば、Entity ではお気に入りは 2 だけですという状態になります。

---

## Event Sourcing

* システムの中で起きた**イベント**を永続化する
.float-top-40[
![](resources/img/event-sourcing.4.svg)
]

???

というふうな感じで、イベントが処理されていきます。
そして、この Event Source に並んでいるこれらのイベントが時系列順に永続化されます。

---

## Event Sourcing

* デメリット
  * データの集計にコストがかかる
  * ⇒ CQRSで解決できる

???

残念ながら、Event Sourcing にはデメリットがあります。
それは、データの集計にコストがかかるということです。

例えば、あるつぶやきがお気に入りされた数を数えたいという場合、全てのイベントを順番に見ていかないといけないので
とても時間がかかってしまいます。

しかし、このデメリットは CQRS という方式で解決することができます。

---

## CQRS

* .bold[C]ommand and .bold[Q]uery .bold[R]esponsibility .bold[S]egregation
    コマンドクエリ責務分離
* コマンド(書き込み)とクエリ(読み込み)を分離する
* 書き込み側と読み込み側で
    * 異なるDB・データ構造が使える
    * 別々にスケールできるようになる
    * ⇒ Command-Side にイベントソーシングを使い<br>Query-Side に集計しやすい形で永続化する

???

CQRS は日本語でコマンドクエリ責務分離と言います。
つまり、データの書き込みをするコマンドと、データの読み込みをするクエリを分離しましょうという考え方です。
CQRS にすることによって、書き込み側と読み込み側で異なるDBの実装やデータ構造が使えるようになります。

さらに、読み込み側と書き込み側で別々にスケールさせることもできるようになります。

Event Sourcing とどう組み合わせるのか？というと、
Command-Side に Event Sourcing を使って Query-Side へ集計しやすい形で永続化します。

イメージしやすいように図にしてきました。

---

## CQRS

.center[
![](resources/img/es-and-cqrs.svg)
]

???

* 上が Query-Side で、下が Command-Side
* 各箱の中の名前は、後ほどの実装にも出てくるので Lagom のクラス名で書いています
* Command-Side から見ていく

----------

* API の呼び出しがあると、まず ServiceImpl が Command なのか Query なのかを判断して処理します
* Command だったときは Command が PersistentEntity に送られます
* PersistentEntity は Command から Event を作って、DBに永続化します。永続化できたら、自身の状態を更新します。

----------

* 次にQuerySideです
* QuerySide では EventProcessor というものが Event の入っているDBからイベントをポーリングで取ってきます
* このイベントにもとづいてQuery側のDBをCRUDで普通に更新をかけます。
* 外からQueryのAPI呼び出しがあれば、ServiceImplでクエリを発行してデータをレスポンスします

---

## CQRS

* デメリット
    * 書き込み・読み込みで完全な一貫性を保てなくなる
      * 十分な時間が経つと整合性がとれる (結果整合性)
      * ⇒ 一時的に一貫性が取れてなくても問題ないよう
      ビジネスやシステムを設計する

???

でも残念ながら、この方式にはデメリットがあります。
それは、書き込みと読み込みで完全な一貫性を保てなくなります。

一時的に一貫性のない状態になって、十分な時間が経つと整合性がとれるような状態になります。
この性質は結果整合性といいます。

このデメリットがあるので、Event Sourcing と CQRS を採用する場合は一時的に一貫性がとれていなくても
問題ないようにビジネスやシステムを設計する必要があります。

では、早速 Event Sourcing の実装をしていきます。

---

## Event Sourcing で実装してみる

* WIP のところを実装をします

.center[![](resources/img/services-write2.svg)]

???

ここでは、お気に入りの削除を永続化するところを実装します。

---

## Event Sourcing で実装してみる

* .with-checkbox-off[FavoriteService でAPIの定義を確認]
* .with-checkbox-off[FavoriteServiceImpl にコマンドの送信を実装]
* .with-checkbox-off[FavoriteEntity にイベントの永続化を実装]

.height-10.center[![](resources/img/services-write2.svg)]

???

これからやることは、3つあります。

* まず、FavoriteService でお気に入り削除のAPIがどのように定義されているか確認します。
* 次に FavoriteServiceImpl で Entity にコマンドを送るという処理を実装します。
* 最後に、FavoriteEntity でイベントの永続化をします。

---

## APIの定義を確認

.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
ServiceCall<FavoriteId, NotUsed> deleteFavorite(String `userId`);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
*          pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `pathCall` の第一引数が API のURLになる
    * URL の `:userId` はパラメータ
    * 例) http://localhost:9000/api/favorites/HOGE/delete

???

ではまず、APIの定義を確認していきます。FavoriteService のソースを開いて下さい。

ここでは、APIの定義がされています。
pathCall の第一引数にAPIのURLが定義されています。
第二引数にメソッド参照が渡されていますが、これは上のほうで定義されている ServiceCall を返すメソッドです。
1つ userId という引数がとれるようになっていて、ここにはURLの中にある`:userId`の部分にある文字列が渡されます。

つまり、このURLが呼ばれると userId をパラメータとして deleteFavorite メソッドが呼ばれる。ということになります。

---

## APIの定義を確認
.with-code-annotation[
.activator-ui-link[[FavoriteService.java:42](#code/favorite-api/src/main/java/sample/chirper/favorite/api/FavoriteService.java:42)]
```java
*ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId);

@Override
default Descriptor descriptor() {
    return named("favoriteservice").withCalls(
            pathCall("/api/favorites/:userId/delete", this::deleteFavorite)
    )
}
```
]

* `ServiceCall` : APIの呼び出しを抽象化したもの
    * 第一型引数: Request Body の型
  .small[JSONから自動でデシリアライズされる]
    * 第二型引数: Response Body の型
  .small[[NotUsed](http://doc.akka.io/japi/akka/snapshot/akka/NotUsed$.html)はレスポンスボディ無しを表す]

???

つぎに、ServiceCallを少し詳しく見ていきます。
ServiceCall は２つの型引数がとれるようになっています。

第一型引数は Request Body、第二型引数は Response Body の型になります。
この2つの型引数のオブジェクトは必要に応じて自動的にJSONからデシリアライズされたり、JSONにシリアライズされたりします。

NotUsed は少し特殊な型で、ボディなしを表す型です。
第二引数に指定していると、レスポンスボディがなしという意味になります。

では次は、FavoriteServiceの実装に移って、deleteFavoriteメソッドを実装していきます。

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
        return CompletableFuture.completedFuture(NotUsed.getInstance());
    };
}
```
]

* 「`FavoriteId` のリクエストを受けて `CompletionStage<NotUsed>` を返す」関数を返す
* ややこしいが、あまり気にせず`->`の先で`request`を使った処理を書けば良い

???

deleteFavorite メソッドには、ServiceCall の第一型引数にある FavoriteId を受けて、
受けて NotUsed の CompletionStage を返す関数を定義します。

ちょっとAPIがややこしいですが、あまり深く考えずに request の矢印の先にある括弧の中に処理を書けばよいです。

ここに、TODOのコメントに書いていますが、
お気に入りを削除するための DeleteFavorite コマンドを FavoriteEntity に送信するコードを実装します。

---

## コマンドの送信を実装

.with-code-annotation[
.activator-ui-link[[FavoriteServiceImpl.java:56](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteServiceImpl.java:56)]
```java
@Override
public ServiceCall<FavoriteId, NotUsed> deleteFavorite(String userId) {
    return request -> {
        // TODO: STEP3 - DeleteFavorite(コマンド)をFavoriteEntityに送る
*       DeleteFavorite command = DeleteFavorite.of(userId, request.getFavoriteId());
*       CompletionStage<Done> deleting = favoriteEntityRef(userId).ask(command);
*       return deleting.thenApply(ack -> NotUsed.getInstance());
    };
}
```
]

* `DeleteFavorite`.small[(コマンド)]を FavoriteEntity に `ask` する
* FavoriteEntity は `userId` ごとに存在している
* `Done` が返って来たら `NotUsed` を返す

???

書くコードはこんな感じです。

DeleteFavorite というコマンドを作って、userId に紐づく favoriteEntityRef に対してコマンドを ask メソッドで送信します。
EntityRef はここでは、Entity の実体へのプロキシだとイメージしておいてもらえると大丈夫です。

Entity は userId ごとにインスタンスが存在します。
つまり、ユーザー一人に対して Entity が 1つ割あたっているとイメージしてもらえるとよいです。
ask の結果として、コードでは ack と書いちゃってますが、Done が返ってきたら、ServiceCall の第二型引数が NotUsed なので、NotUsed を返すようにします。

---

## Entity？

* サービスの状態を持つもの
* コマンドを受け取り、処理を行う
* コマンドからイベントを作り、イベントを永続化する
* イベントが永続化できたら、自身の状態を更新する
* 状態が失われたら**イベントを再生**して復元

???

で、これまでちょくちょく Entity という言葉が出てきているので、
詳しく解説しておきます。

(上の説明)

ちなみに、LagomにおけるEntityはDDDにおけるEntityの性質を備えています。

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:27](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:27)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.setCommandHandler(.....,
      (.....) -> { ..... }
    );
    b.setEventHandler(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

???

ではまず、FavoriteEntity のソースに移動してください。

ここでは、2つのことをやります。

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    `BehaviorBuilder` b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    b.`setCommandHandler`(.....,
      (.....) -> { ..... }
    );
    b.`setEventHandler`(.....,
      (.....) -> { ..... }
    );
    //////////////////////////////////////////////
    return b.build();
}
```
]

* `BehaviorBuilder` に**コマンド**と**イベント**のハンドラ(関数)を登録する

???

BehaviorBuilder という Entity の振る舞いを定義するためのビルダーを使って、
コマンドとイベントのハンドラを登録します。

---

## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
public Behavior initialBehavior(Optional<FavoriteState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(snapshotState.orElse(FavoriteState.builder().build()));
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
*   b.setCommandHandler(DeleteFavorite.class,
*       (request, ctx) -> {
*           FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
*           return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
*       }
*   );
    //////////////////////////////////////////////
    return b.build();
}
```
]

???

まずは、コマンドのハンドラを登録します。
第一引数に、コマンドのクラスを、第二引数にそのコマンドを受信したときに実行する処理を関数で渡します。
まず、FavoriteDeleted というイベントをリクエストのデータを使って作ります。

で、ctxの thenPersistの第一引数に永続化したいイベントを指定して、イベントが永続化できた後の処理を第二引数で指定します。
ここでは、Doneという完了を表すオブジェクトを返信しています。

ちなみに、FavoriteDeleted の引数が request のデータを入れているだけなので、コマンドを直接永続化すればいいんじゃないの？という疑問が出てくるんですが、

Command と Event を別にすることによって、Command の情報に加えて、Entity側の都合で例えば現在時刻をイベントに含めたりすることができるようになります。
これによって、Commandを送る側は最低限の情報だけ送ればよくなります。

---


## イベントの永続化を実装

.with-code-annotation[
.activator-ui-link[[FavoriteEntity.java:47](#code/favorite-impl/src/main/java/sample/chirper/favorite/impl/FavoriteEntity.java:47)]
```java
    //////////////////////////////////////////////
    /*
     * TODO: STEP3 - DeleteFavorite(コマンド)が送られてくる
     *  → FavoriteDeleted(イベント)を作成
     *  → イベントを永続化
     *  → Done を送り返す
     */
    b.setCommandHandler(DeleteFavorite.class,
        (request, ctx) -> {
            FavoriteDeleted event = FavoriteDeleted.of(request.getUserId(), request.getFavoriteChirpId());
            return ctx.thenPersist(event, (evt) -> ctx.reply(Done.getInstance()));
        }
    );
    // TODO: STEP3 - FavoriteDeleted(イベント)が起きたときは状態からfavoriteId を削除
*   b.setEventHandler(FavoriteDeleted.class,
*       (evt) -> state().deleteFavoriteId(evt.getFavoriteId())
*   );
    //////////////////////////////////////////////
```
]

???

次は、イベントハンドラを定義します。
コマンドハンドラでのイベントの永続化が完了すると、イベントハンドラの処理が呼ばれます。
先ほどと同じように、ハンドルしたいクラスを第一引数に渡して、第二引数で処理を書きます。

ここでは、Entityの状態を更新します。
state メソッドでこの Entity の状態を持つオブジェクトが取れるので、その deleteFavoriteId メソッドにイベントに入っている favoriteId を渡します。
これによって、このEntityはこのお気に入りが削除された状態になります。

実装が終わったら、動きを確認してみてください。

---

## 動きの確認

* .with-checkbox-on[お気に入りが解除できるようになっている]
* .with-checkbox-on[お気に入りの数が変化するのにタイムラグがある]
.therefore[Query-Side で集計しているため]

???
【10分】

まず、お気に入りが解除できるようになっていることを確認してください。
そして、解除したときにお気に入りの数が変化するのにタイムラグがあるのを確認してください。
何度か画面を更新すると反映されると思います。

ここにタイムラグがあるのは、お気に入りの数が CQRS の Query-Side で集計されているためです。

---

## 実装が間に合わなかった場合

回答は下記のコマンドでチェックアウトできます

.with-code-annotation[
`Terminal`
```bash
# lagom-hands-on-development に移動して実行してください
$ git checkout step3
```
]

???

実装が間に合わなかった場合はこのコマンドでチェックアウトできます。

---

## まとめ

* 非同期処理でレイテンシを低くする
* Event Sourcing + CQRS で永続化機能に<br>高いスケーラビリティと耐障害性を持たせる
    * 結果整合性を意識した設計にする

???

ハンズオンは以上です。

今回は Lagom の設計ポリシーから2つのことを知って頂けたかと思います。
一つは、非同期処理でレイテンシを低く抑えるということ。
二つ目は、Event Sourcing と CQRS を使って、永続化機能に高いスケーラビリティと耐障害性を持たせるということ、
ただし、これを使う場合は結果整合性を意識した設計にする必要があります。

今回知って頂けたことが、今後の皆さんのマイクロサービスの開発に役立つことを願っています。

---

## 参考資料

* [マイクロサービスアーキテクチャ (O'Reilly)](https://www.oreilly.co.jp/books/9784873117607/)
* [Reactive Design Patterns (Manning)](https://www.manning.com/books/reactive-design-patterns)
* [Developing Reactive Microservices (O’Reilly)](http://www.oreilly.com/programming/free/developing-reactive-microservices-signup.html)

???

今回のハンズオンの参考資料はこちらです。

今回のハンズオンで、大規模なマイクロサービスの開発、大変そう…
と思われたかもしれません。
でも、ご安心下さい。

実は生産技では

---

## TIS㈱ リアクティブ・システム<br>コンサルティングサービス

* Reactive Microservices Architecture
* Akka / Play / Scala
    * POC
    * 設計レビュー
    * コードレビュー
    * システム構築

.footnote[
https://www.tis.jp/service_solution/goreactive/

TIS は Lightbend 社の認定コンサルティングパートナーです
]

???

リアクティブ・システムコンサルティングサービスを行っています。
今回ハンズオンした Reactive な マイクロサービスアーキテクチャはもちろん Akka、 Play、Scala
などといった技術の POC をやってみたい、設計レビューしてほしいなどといったご用件があれば
生産技がお手伝いさせて頂きます。

是非ご相談ください。

---
class: middle, center

# Thank you!

???

本日はありがとうございました。

---

class: center, middle

## おまけ
# CircuitBreaker の紹介

---

## CircuitBreaker とは？

.small[
* 外部サービスに障害が起きているとき、すぐエラーの応答を返す仕組み
    * 障害時のリトライによるネットワーク帯域の無駄遣いが減る
    * レイテンシを低く抑えられる
* Close・Open・Half-Open の状態をとる
]

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

## Open？ Close？

* CircuitBreaker はもともと電子工学の言葉
* 電流が流れすぎているときに電流を遮断する保護回路

.center.height-6[
![](resources/img/cb-open-close.svg)
]

* **Close**: 回路が**閉じた**状態 = 通信できる
* **Open**: 回路が**開いた**状態 = 通信が遮断されている

---

## CircuitBreaker のしくみ

.center.height-6[
![](http://www.lagomframework.com/documentation/1.0.x/java/resources/guide/services/circuit-breaker-states.png)
]

.small[
* **Close**: 外部サービスへリクエストする
* **Open**: すぐにエラーを返す
* **Half-Open**: リクエストを試す
    * Open から一定時間で切り替わる
    * リクエストが成功したら Close に戻る
]

.footnote[
引用: [Lagom #Consuming services](http://www.lagomframework.com/documentation/1.0.x/java/ServiceClients.html)
]

---

### Lagom での CircitBreaker

* 標準で備えていて、デフォルトで有効
* 外部へのリクエストは CircitBreaker を通じて行う

※ CircitBreaker は呼び出し側の制御
Lagom以外のサービスからLagomのAPIを呼ぶ場合は注意


</textarea>
  <style>
    .remote-controller {
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 999;
      background: rgba(255, 255, 255, 0.50);
      border: 0.05rem solid rgba(255, 255, 255, 0.80);
      padding: 0 0.5rem 0.3rem 0;
    }
    .remote-controller label {
      font-size: 0.6rem;
      color: rgba(0, 0, 0, 0.50);
    }
    .remote-controller input[type="checkbox"] {
      max-width:  0.5rem;
      max-height: 0.5rem;
    }
    .subscribe-control {
      cursor: pointer;
    }
    @media print {
      .remote-controller {
        display: none;
      }
    }
  </style>
  <script src="resources/remark-0.13.0.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <script src="resources/reconnecting-websocket.min.js"></script>
  <script src="resources/remark-remote.js"></script>
  <script src="resources/js.cookie.js"></script>
  <script>

    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      highlightSpans: true
    });

    $(function() {
      // var remote = remark.remote(slideshow, "ws://localhost:9000/");
      var remote = remark.remote(slideshow, "wss://stark-dusk-4378.herokuapp.com/");
      console.log(remote);
      remote.ondisconnect = function() {
        alert("通信が切れました。同期を有効にするにはリロードする必要があります。");
      };
      if (window.location.search && window.location.search == "?control=true") {
        // Controllers
        $(".remote-controller").hide();
        var passcode = window.prompt("passcode?", "");
        if (passcode === null) {
          return;
        }
        remote.control(passcode);
      } else {
        // Follower
        var following = remote.follow();
        var $enableSync = $("#enable-sync");
        following.followWhen = function() {
          return $enableSync.prop("checked");
        };
        $enableSync.click(function() {
          var syncEnabled = $enableSync.prop("checked");
          if (syncEnabled) {
            following.sync();
          }
          Cookies.set("syncEnabled", syncEnabled, { expires: 1 });
        });
        following.ondefiance = function() {
          $enableSync.prop("checked", false);
          Cookies.set("syncEnabled", false, { expires: 1 });
        };
        var syncEnabled = Cookies.get("syncEnabled");
        if (typeof syncEnabled !== "undefined") {
          $enableSync.prop("checked", syncEnabled != "false");
        }
      }
    });
  </script>
  <script>
    // 全てのリンクが別のタブで開くようにする
    $('a').attr({target: "_blank"});
    $('.activator-ui-link a').each(function() {
      $(this).attr({target: "activator-ui", href: "http://127.0.0.1:8888/app/lagom-hands-on-development/" + $(this).attr("href")});
    });
  </script>
</body>
</html>
